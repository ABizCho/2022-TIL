# 2022 TIL Records
<img src="./src/mdHeader.jpg">

<br><br>

매일 새로이 공부하는, 또는 새로이 배우는 것들을 제각기 목적에 맞는 서로 다른 공간에 나누어 관리하는 것은 금일의 기억과 기록을 파편화 시키며 재참조의 어려움을 낳습니다. 그리고 기록과 기억의 파편화는 소실로 이어질 가능성이 큽니다.

<br>

오늘의 공부를 더 가치있게 기록하기 위해, 이렇게 구축한 작은 시스템이 향후 나에게 큰 도움을 줄 것임을 잘 알기 때문에,
지금부터라도 TIL 레포에 곳곳에서 모은 작지만 가치있는 지식의 조각들로 미래의 어려움을 밝힐 지혜의 등대를 쌓아 올리고자 합니다.
<br>

개발지식 뿐 아니라 TIL로 기록할 가치가 있는, 내 개발과 서비스 사고에 도움이 되는 다양한 것들을 남기겠습니다.


<br><br>

# 2022 매일의 기록

## 9월
|날짜|배운것|분야|관련자료|한줄평|
|------|---|---|---|---|
|22.09.22|반응형 디자인 공부|개발: 웹프론트|[CSS: 반응형 웹](https://www.nextree.co.kr/p8622/), [미디어쿼리 예제](https://designbase.co.kr/webcoding-22/)|캡스톤 디자인'머리할래' 프로젝트에 적용하기 위해 웹-모바일 반응형 디자인 공부 / 미디어 쿼리 적용법 4가지(link,style, style-@import, CSS파일) 있음. / 미디어 타입은 대표적으로 all, screen, print 사용/ Fluid Grid, Fluid Layout, Mostly Fluid, Column Drop, Layout Shifter, Tiny Tweaks, Off Canvas, Flexible Imaages 등의 레이아웃 반응 설정법이 있으며 이들을 적절히 사용.|
|-|Styled Components 공부|개발: 웹프론트|[Styled Components for react 사용법](https://www.daleseo.com/react-styled-components/)|캡디 프로젝트에 사용하기 위해 styled-components를 학습했다.|
|22.09.21|HTTP1.0-HTTP3.0 SPDY, QUIC|개발: 네트워크|-|-|-| 
## 8월
|날짜|배운것|분야|관련자료|한줄평|
|------|---|---|---|---|
|08.06~18|인싸푸드 팀플 협업 및 1차 마감|개발: 웹개발|-|-|
|22.08.05|인싸푸드 팀플) client & server 개발환경 및 디렉구조 구축|개발: 웹개발|-|-|
|-|SMA 5주차) |데이터분석: SMA|-|-|
|-|웹트랙 w5D2 페이지네이션 복습|개발: 웹프론트|-|-|
|22.08.04|웹트랙 w5D4-Final ) 배포: 네클 가상 Ubuntu(+nginx) + [Putty, Filezilla] |개발: 웹프론트|[MyNote: 네이버 클라우드 서비스 배포 Process 총정리](https://github.com/ABizCho/Aihub_webTrack/blob/main/Learn/week5/Day2-4/reactPr/DAY2_2_%EB%84%A4%ED%81%B4%20%EB%B0%B0%ED%8F%AC%20PROCESS%20%EC%B4%9D%EC%A0%95%EB%A6%AC.md)|오늘은 웹트랙 교육일정의 마지막 날이었음. 물론 팀프로젝트 일정이 남아있으나, 정말 열심히 양질의 교육을 해주신 유영빈 강사님을 보내드려야 했음. 그렇게까지 안해주셔도 될텐데도 끝까지 진심으로 좋은 수업 해주셨던 강사님께 너무 감사해서 디스코드로 기프티콘을 보내드렸음. 어쨌든 마지막 수업에는 지금까지 만들어본 서비스를 배포해보는 실습을 진행함. 네이버 클라우드로 우분투의 가상서버를 구축했고 공개IP를 구매하여, 우분투의 apt에서 경량 웹서버인 nginx를 받아 구동하였고, putty와 Filezilla를 설치하여 가상서버로 열었던 ubuntu 환경에 접근 및 제어하며, 서비스를 배포해봤음. 첨부해 둔 MyNote에 매우 자세하게 작성해뒀으니 참고. cors(cross-origin request)에러 우회나 SSL(http)적용 방법과 DB 배포법 혹은 포트포워딩 등 추가적으로 알아둬야 할 중요한 개념들을 짧은 시간이지만 중요성을 강조하며 빠르게 짚어주셨음. / 강의의 마지막에 짧은 교육기간이었으나, 국소적인 내용보다도 웹개발의 큰 로직들을 정확히 이해했기를 희망한다고 말씀하신 것을 보고 얼마나 강사님이 진심으로 교육해주신지 다시한번 느껴짐. 이제 교육은 끝났고 프로젝트에 돌입하는데 교육에 대한 전체적 내용정리 및 회고를 방학이 가기 전 반드시 작성해야겠음.|
|-|웹트랙 w5D4-Final ) TensorFlow 학습 및 모델 Export, Import |개발: 웹개발 |[(1)Ref: TensorFlow.js](https://github.com/ABizCho/Aihub_webTrack/blob/main/Learn/week5/Day4/LectureNotes.md)|Tensorflow.js의 모델을 학습시키고, 해당 모델을 export&import하여 활용하는 방법 또한 배움. // 만일 서비싱하며 model이 반복적으로 학습 및 업데이트 되어야 한다면, 학습 로직때문에 당연히 백엔드단에 위치하여 클라에서 import되어 사용해야 할 것이고, 만일 최초학습 이후 변형이 없을 예정이라면 클라단에서 사용자의 최초 접속 시 모델을 브라우저 로컬 스토리지등에 저장해두고 사용토록 할 수도 있음. 이는 AI모델 사용 전략을 고려하여 결정할 일이며 우리 인싸푸드 팀은 최초 학습 이후 개선이 없다는 가정하에, 모델을 클라에 두고 사용할 예정임.|
|-|인싸푸드 팀플) 회의- Data 스키마 정의, 금주차 역할분배|개발: 웹개발|[인싸푸드 노션-DB](https://psychedelic-bison-ffe.notion.site/DB-d37787ada25c4957b013a82f8760b66b)|요구사항 명세별 기능들을 담당해 구현하기로 했으나, 우선 큰 작업환경을 구성하고 들어가야 할 것 같아서 가장 중요한 데이터들을 식별하고 스키마에 대해 논의하며 작성했음. 핵심 스키마는 유저, 음식, history card이며, 음식 스키마는 static함. history card는 유저와 음식의 데이터들을 reference하여 만들어지는 스키마임.
|-|nginx란?|개발: 웹개발| [(1)Ref: Nginx 이해하기](https://icarus8050.tistory.com/57) / [(2)REF: egoing-NGINX](https://opentutorials.org/module/384/3462)|nginx란 차세대 웹 서버(HTTP Server)로 불리며, 경량 웹 서버임. 아파치의 독주에 제동을 거는 중. 더 적은 자원으로 더 빠른 데이터를 서비스 할 수 있음./ 아파치 서버와 특징적으로 다른 것을 짚어보겠음/ 아파치는 클라로부터 받은 요청을 처리할 때, 새로운 프로세스 또는 스레드를 생성해 처리한다고 하여 - 요청마다 쓰레드가 새로 생성되므로, 접속하는 사용자가 많을 경우, 그에 비례해 쓰레드가 생겨 CPU와 메모리 자원 소모가 커짐.// 반면 Nginx는 `Event-Driven`구조로 동작하여, 한 개 또는 고정된 프로세스(스레드)만을 생성하여 사용하며, 비동기 방식으로 들어온 요청들을 Concurrency하게 처리 가능함. 이렇 듯 Apache가 사용하는 사용자접속-스레드생성의 불필요한 생성 비용이 존재하지 않고, 적은 자원으로도 효율적 서버 운용이 가능함. 덕분에 단일 서버에서도 동시에 많은 연결 처리가 가능함. 더 자세히는 [(1)번 ref문서](https://icarus8050.tistory.com/57)참고.|
|-|리눅스(커널)과 Ubuntu|개발: OS|[(1)Ref Best!: 리눅스와 우분투](https://hanamon.kr/%EB%A6%AC%EB%88%85%EC%8A%A4%EB%8A%94-%EB%AC%B4%EC%97%87%EC%9D%B4%EA%B3%A0-%EC%9A%B0%EB%B6%84%ED%88%AC%EB%8A%94-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80/?utm_source=pocket_mylist) / [(2)Ref: Linux 커널이란?](https://www.redhat.com/ko/topics/linux/what-is-the-linux-kernel?utm_source=pocket_mylist) / [(3)Ref: 우분투 나무위키](https://namu.wiki/w/%EC%9A%B0%EB%B6%84%ED%88%AC) / [(4)Ref: 우분투 위키백과](https://ko.wikipedia.org/wiki/%EC%9A%B0%EB%B6%84%ED%88%AC)|금일 웹트랙 마지막 과정에서 네이버클라우드 에서 가상서버로 Ubuntu를 구성하고 이를 통해 배포를 진행하다가 우분투가 그래서 뭔데?라는 의문이 생겼고, 그래서 개인적으로 조사 학습 했음. 막연히 리눅스와 우분투를 OS라고만 알고 있었는데, 공부해보니 엄연히 따지자면 리눅스는 그 자체로는 OS가 주요히 사용되지 않고 새로운 배포판 OS를 Customized하기 위한 잘 만들어진 커널(OS구성요소)이 핵심적으로 사용됨. 커널은 OS의 주요 구성요소로, 운영체제는 크게 `사용자영역`과 `커널영역`으로 나눠짐. 이에대한 자세한 내용은 [(1)번 문서](https://hanamon.kr/%EB%A6%AC%EB%88%85%EC%8A%A4%EB%8A%94-%EB%AC%B4%EC%97%87%EC%9D%B4%EA%B3%A0-%EC%9A%B0%EB%B6%84%ED%88%AC%EB%8A%94-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80/?utm_source=pocket_mylist), [[2]번 문서](https://www.redhat.com/ko/topics/linux/what-is-the-linux-kernel?utm_source=pocket_mylist)를 참고. /  각설하고, 리눅스는 새로운 자식 배포판 OS들을 위한 어머니격<br><br>// 어쨌든 배운점을 정리하자면, 우분투는 오픈소스 OS-커널인 Linux를 기반으로 탄생한 수 많은 자식 배포판 OS들 중 하나이며 매우 유명함. 정확히는 리눅스 자식 중 `데비안`의 리눅스를 포크해 만들어 진 것. / 우분투는 다양한 버전이 존재하며, 데스크톱 버전은 개인용 컴퓨터에 적합. `Ubuntu server`는 클라우드 및 서버에 적합함. 그외에도 우분투 코어, 에듀분투 등 Iot, 교육용, 태블릿용 등 수많은 환경에 적합한 우분투 버전들이 있음. / 우분투에는 GUI, CLI방식 입력이 가능./ 사용자는 `Ubuntu 소프트웨어 센터` 혹은 `다른 Apt 기반 패키지 관리 도구`에서 더 많은 무료 소프트웨어 및 도구를 받아서 Ubuntu에서 사용할 수 있음. 오늘 배포 실습을 진행하면서, 우분투에 `apt`명령어를 이용해 `nginx`를 설치해서 사용했는데, 이런 방식을 말하는것이리라 생각함. / 우분투는 또한 바이러스, 웜,스파이웨어 및 기타 맬웨어 같은 악성 소프트웨어로부터 데이터 및 리소스를 보호하는 보안 운영 체제임|
|-|도메인 주도 개발 (DDD)|개발: 웹|[Best Ref: (1)DDD 핵심만 빠르게 이해하기](https://happycloud-lee.tistory.com/94) / [Ref: (2)도메인주도설계 in real](https://medium.com/react-native-seoul/%EB%8F%84%EB%A9%94%EC%9D%B8-%EC%A3%BC%EB%8F%84-%EC%84%A4%EA%B3%84-domain-driven-design-in-real-project-bounded-context-e2bee96deeb2) |양재허브의 교육이 끝나고 본격적으로 팀프로젝트가 시작되기 전임. 요구사항 명세서로 식별,정의해 둔 기능단위별로 작업하기로 팀끼리 합의를 봤는데, 이를 위해선 가장 먼저 프로젝트의 큰 프레임을 구성해 둘 필요성을 느낌. 이를 내가 이번주말 내로 작업하여 main branch에 올려두기로 했는데, 디렉토리를 어떻게 구성할 지 구조적인 고민을 했음. 디렉토리 구성 방법론 등에 대해 조언을 들어보기 위해 카카오페이 주니어개발자 제이슨에게 현 상황을 공유하며 자문을 구했는데, 기능별 작업이면 DDD패턴을 적용하는게 좋겠다고 조언해줌. `DDD`, 즉 도메인 주도 설계 방법은 이전에 뚜-잇! 플래너 프로젝트를 진행할 때도 적용해본적이 있는 방법임. 다만 당시에는 웹개발을 완전히 처음 접하며 팀프로젝트에 참여했던 것으로, 속성으로 독학하며 생존형 필수지식만을 학습했기에, 웹개발에 있어 각 구성들의 역할이나 MVC패턴 등 기본적 웹개발 지식 혹은 디렉토리 구조 등에 대한 이해가 부족했고, 필요성을 공감하지 못하고 개념만 간단히 이해하고 진행했었다. 하지만 이번 웹트랙 과정을 들으며 웹개발의 전체적인 로직을 이해하며 학습을 진행하고 나니 그 필요성과 장단점을 이해할 수 있었음. <br><br>// 본론으로 들어가자면 `DDD`는 도메인 주도 설계의 약자로, SP(Structured Programming)-구조적 프로그래밍에 대비되는 개념이다. 이는 하단의 섹션에서 후술하겠음. 도메인이란 영역,집합이며 DDD에서 말하는 Domain은 비즈니스Domain을 말함. 비즈니스 도메인이란 유사한 업무의 집합을 말함. APP은 비즈니스 Domain별로 나누어 설계 및 개발될 수 있음. / DDD는 선술한 비즈니스 Domain별로 영역을 나누어 설계하는 방법론이며, 이는 제이슨이 설명해준대로 `커뮤니케이션`에 집중하는 설계 패러다임임. 기존의 현업->IT 의 일방향적 소통구조를 탈피해, 현업<->IT의 양방향 커뮤니케이션에 집중해, `Loosely coupling`,`High cohesion`(모듈간 의존성 최소화, 모듈 내 응집성 최대화)의 핵심목표를 가짐. // DDD는 개념적 설계인 `Strategic Design`과 프로그래밍을 위한 구체적 설계인 `Tactical Design`으로 나눠짐. / `Strategic Design`은 Business Context(사용자,상황)에 맞게 설계하자는 컨셉이며 예를들어, 선물구매라는 도메인을 설계할 때, 대상이 애인,부모,자식인지에 따라 달라져야 한다는 개념임. 이런 전략적 설계를 위해, Business Domain의 Context를 Event storming으로 공유하고, 비즈니스 목적별로 서비스들을 그룹핑 해야 함. 해당 Strategic Design의 산출물로는 Domain Model이 있음. 기타 전략디자인 관련 내용은 [(1)번 참고문서](https://medium.com/react-native-seoul/%EB%8F%84%EB%A9%94%EC%9D%B8-%EC%A3%BC%EB%8F%84-%EC%84%A4%EA%B3%84-domain-driven-design-in-real-project-bounded-context-e2bee96deeb2)로 자세히 알아볼 수 있음.<br><br>//`Tactical Design`이 내가 도입하고자 하는 핵심 개념임(인 것 같음..) 지금까지 쭉 자료를 뒤져보며 공부하다가 느낀점은 DDD가 프론트 개발방법론으로 언급되지 않고 있다는 것임. 물론 적용하기 나름이겠으나, 대부분 백엔드를 얘기하고 있다고 느끼며, 제이슨과 함께 말한 프론트엔드 구성방법론으로서 생각하는 그 DDD는 어디에도 나와있지 않아서, 후속적으로 프론트엔드 패턴을 찾아보고 있으나 이런 개념은 언급돼있지 않음. 일단 공부는 여기까지만 하고 `그` 함부로 명명하기 힘든 방법으로 설계부터 시작해봐야겠음.| 
|22.08.03|웹트랙 w5D3) 카카오 소셜 로그인 구현|개발: 웹프론트|[MyMd: 카카오 소셜로그인 인증Flow](https://github.com/ABizCho/Aihub_webTrack/blob/main/Learn/week5/Day2-4/reactPr/DAY3_1_%EC%B9%B4%EC%B9%B4%EC%98%A4%EC%86%8C%EC%85%9C%EB%A1%9C%EA%B7%B8%EC%9D%B8.md)|카카오 소셜 로그인 기능 구현을 배우고 개인 프로젝트에 적용해봄. 카카오 Developers에서 제공하는 REST_API를 사용하여 구현 가능함. / 전체적인 로직은 이러함. // 1.클라(리액트)는 사용자가 카카오 로그인 버튼을 클릭함으로써 카카오에 인가코드 요청, / 2.카카오는 인가코드를 클라에 발급해줌 / 3.클라는 백에 인가코드와 함께, 요청(회원가입 || 로그인) / 4. 백은 카카오에 클라로부터 받은 인가코드를 통해 토큰 발급 요청(by Redirect URI)/ 5. 카카오는 Redirect URI 일치를 확인(유효성 검증) 백에 도큰 발급/ 6. 백은 카카오 토큰으로 유저정보 활용해, 우리서버 전용 토큰 발행(다음부턴 카카오 안들려도됨)/ 7. 전용토큰 클라로 응답하며 로그인 허용/ 8. 클라는 토큰을 응답받아 유효성을 확인하였고, 리다이렉트로 로그인 후의 사용자 화면으로 전환함|
|22.08.02|SMA 4주차) 3-4 토큰화 개선작업 반복 & DTM 동시출현 빈도 및 Network 시각화 |데이터분석: SMA|[MyRepo: DTM to Network](https://github.com/ABizCho/SMA_2022summerProject/blob/main/TASK/week4/Tasks/T3_DTM_to_Network.ipynb)| Mecab 토큰화 -> DTM 구성 및 결과물 확인을 반복적으로 수행하며, 전처리 로직과 결과물을 개선한 결과, 어느정도 유의미한 결과물들이 보이기 시작함. 첫 번째로, 동시출현 빈도 Dataframe에서 기존에 1음절씩 분리되었던 'N / 주 / 차'(SN + NNBC + NNG)를 복합명사 처리로직에서 관리해주어 'N주차'로 합성되었고, 이에 따라 N년차와 함께 등장하는 동시출현 키워드로부터, 연차별 고민 혹은 관심사를 식별할 수 있게 되었음. 이외에도 `si업체` + `뻥튀기` 라는 동시출현 조합이 적지않은 빈도로 등장하는 것을 확인하였는데, 당장 내가 어떤의미인지는 알 수 없으나 분명 의미있는 해석이 나올 수 있을 것이라 확신함. 아직은 비교적 적은수( 7만개 ) 의 `title`데이터 뭉치만으로 로직을 돌리고 개선하며 로직작성에 시간을 투자했으나, 어느정도 전처리 및 결과출력 로직이 완성되었기에 5주차부턴 `content`(90만개) 데이터를 투입하여 훨씬 유의미한 결과물들을 많이 얻을 수 있을것으로 기대. networkX를 이용한 네트워크를 그렸는데 matplotlib의 font-manager가 제대로 작동하지 않는 점에서 트러블슈팅을 수행했고, 네트워크 결과물에 내가 생각한 Nodes의 degree별 노드 사이즈 조정 로직이 제대로 적용 안된 아쉬움이 남음. 5주차에 이를 개선하고 유의미한 해석결과를 얻기를 희망함.|
|-|SMA 4주차 마감미팅|데이터분석: SMA|-|상기의 4주차 작업을 바탕으로 발표물을 만들고, 교수님 및 프로젝트 참여학우들과 4주차 마감 미팅을 진행함. 지속적 전처리 로직 개선에 집중하고 있다는 점을 강조했고, 교수님도 이의 필요성에 충분히 공감해주셨으나 이는 사실 절대 마무리될 수 없는 작업임을 일러주셨음. 따라서 지속적으로 개선하는 건 필수적이며 바람직하지만, 어느정도 나만의 선을 정해두고 타협해야할 시점을 정하라고 말씀해주셨음. 이비즈 랩실 주피터 토큰만료 이슈에 대해서 간단하게 언급했는데, 함께 토큰을 공유받은 다른 학우님이 slack DM으로 본인이 Quit을 눌러서 서버 인증이 만료됐는데, 이게 내 환경까지 공유되고 있는 줄 몰랐다고 솔직하게 사과해주셨는데, 왜 서버가 닫혔는지 의아했는데 명료해져서 기분이 좋아짐.|
|22.08.01|웹트랙 w5D1) Express.js(+MongoDB) 백엔드 결합 및 라우팅 구현|개발: 웹프론트|[MyRepo:W5D1](https://github.com/ABizCho/Aihub_webTrack/tree/main/Learn/week5/Day1/pr1_react)|07.22 W3d5에 작업했던 백엔드 디렉을 실습중이던 클라디렉과 형제레벨에 위치시켰으며, 리액트 라우팅을 구현함.|
|-|SMA 4주차) 3-4주차 토큰화&전처리 반복 프로세스 정리 문서화|데이터분석: SMA|[w4_1_IterTaskCycle.md](https://github.com/ABizCho/SMA_2022summerProject/blob/main/docx/w4_1_IterTaskCycle.md)|3-4주차에 작성 및 수행한 mecab토큰화 ~ 복합명사화 로직 ~ 전처리에 이르는 반복수행 작업의 기능별 모듈화된 체계를 정리함|



<br><br>

<!-- |D|Sub|Cat|[ref]()|rev| -->
## 7월
|날짜|배운것|분야|관련자료|한줄평|
|------|---|---|---|---|
|22.07.31|SMA jupyter 및 vs code 파일,디렉 정리|데이터분석: SMA|-|이비즈 랩실의 주피터와 vs code로 작업을 병행하다보니 파일,폴더 정리체계가 난잡해짐. 현재 1주차 output으로부터 3주차 mecab 토큰화, 자체 복합명사 처리로직과 이후의 NLP과정을 반복적으로 수행중인데, 기능단위별 파일간 input output이 존재하여 모듈화시켰는데, 폴더및 파일구조 및 정리체계를 확립해두지 않는다면, 데이터와 수행프로세스가 꼬일 수 있다고 판단하여 우선 주피터 및 vs code에 산재된 로직파일 및 outputs를 vscode에 새로운 체계하에 정리해둠.|
|22.07.29|웹트랙 w4D5) 영화 리뷰 서비스-2: 클라<->서버 요청응답 로직 for 로그인, 회원가입 using Axios|개발: 웹프론트|[MyRepo: 리액트 영화리뷰 ~ Day2](https://github.com/ABizCho/Aihub_webTrack/tree/main/Learn/week4/Day4/pr1_react)|클라쪽 `SignInForm`에서 로그인 이벤트 핸들러를 구현 // `axios` 의존성을 추가함. axios는 ajax에 대응하는 라이브러리로, 클라이언트 단에서 서버로 요청을 보낼 때 사용함. `로그인/회원가입 이벤트 핸들러`내부 로직에서 axios.post()를 이용 작성했음. / axios.post 내엔 서버단에서 정의된 `서버포트~요청` uri를 첫 인자로, 두번째 인자로는 요청 시 서버단에서 참조할 수 있도록 req.body로 사용 될 데이터(객체)를 전달함. / 백엔드와 통신하는 클라파트의 로직은 무조건 비동기 처리를 해줘야 하므로, `async` `await`이 활용됨. -> `async/await`은 근본적으로 Promise의 응용으로, 응답 받은 결과로 `Promise`객체를 반환함. 따라서 응답 후 response로 클라가 처리하게 될 후속 로직은 `.then()`과 `catch()`, `finally()`로 처리해줘야 함. // 구현 후, `sendSignInData`라는 함수에 `axios.post()` 호출부만을 따로 빼서 함수로 구성해줬으며, 이를 호이스팅해서 로그인 이벤트 핸들러 내에서 사용하는 모습으로 리팩토링해줬음.|
|-|웹트랙 w4D5) ""-2: `react-cookie` 이용 로그인 정보 쿠키등록 처리|개발: 웹프론트|[MyRepo: 리액트 영화리뷰 ~ Day2](https://github.com/ABizCho/Aihub_webTrack/tree/main/Learn/week4/Day4/pr1_react)|`react-cookie` 의존성을 추가하고, 앞에서 설명한 `axios.post` 응답의 클라단 후속 처리 로직에서 전역경로의 cookies객체에 응답으로 받은 `userData`를 쿠키로 추가해주었음. 해당 쿠키를 기반으로 로그인한 유저 정보를 관리할 수 있음. // 함께 교육을 듣는 동기형과 시간날 때 마다 pair 프로그래밍을 하며 학습 및 실습내용을 정확히 짚고 가고자 노력하는데, [signInForm.js](https://github.com/ABizCho/Aihub_webTrack/blob/main/Learn/week4/Day4/pr1_react/client/src/pages/user/SignInForm.js)의 `sendSignInData()` 내부에서 `cookies.userData` 쿠키를 로그인 동작 이후 로그로 찍어보려고 할 때, 유저 데이터가 아닌 `undefined`가 반환되는 것을 보고 이유를 알지 못해 함께 cookie동작 원리를 찾아보고 이해하려고 해봄. // 해당 현상이 발생한 라인들을 파일 내 (issue-1-n)이라는 이름으로 주석처리해둠 / 알아낸 결과는 이와 같은데, 전역에서 쿠키를 가져오는 로직이 비동기방식인데, `sendSignInData().then()` 내부의 후속 처리 로직 최하단에 `navigate(~~)`함수가 호출됨. `cookies.userData`는 그보다 상단에 위치해 있으나, 비동기로 실행되므로 사실상 navigate보다 늦게 실행되는 문제가 발생함. navigate로 타 경로로 이동 시에는, 이미 해당 페이지에 맞는 쿠키를 브라우저가 잡아낼텐데 `/review/list`에는 useCookies 자체를 선언해두지 않았으므로 당연하게도 그보다 뒤에 처리되는 `console.log(cookies.userData`에서 userData라는 전역 쿠키는 잡아질 수 없었던 것. / console.log 이하 로직에 setTimeOut(,5000)의 비동기 처리를 수행한 결과 정상적으로 cookies.userData를 출력했음. 비동기의 이해가 얼마나 중요한지 다시 한번 체감했음.|
|22.07.28|웹트랙 w4D4 영화 리뷰 서비스-1: 클라)|개발: 웹프론트|[MyMd: 리액트 영화 리뷰 서비스](https://github.com/ABizCho/Aihub_webTrack/blob/main/Learn/week4/Day4/pr1_react/PR1_REACT.md) / [MyRepo: w4D4-pr1_react](https://github.com/ABizCho/Aihub_webTrack/tree/main/Learn/week4/Day4/pr1_react)|어제까진 리액트의 props state 개념 까지 진행했고, 오늘은 지금까지의 리액트 client단의 기초 지식을 기반으로 view와 router까지 적용된 리액트 서비스를 만들었음. / `/server/...`: 서버에는 3주차까지 진행한 `Express.js와 Mongoose.js`이 적용된 백엔드 디렉터리를 가져와서 구성함. / `client/...`: 오늘은 해당 client 구성을 위주로 진행함. // `라우팅`을 위해 `react-router-dom` 의존성을 추가해줬으며, 해당 의존성의 `{BrowserRouter, Route, Routes}`를 계층적으로 구성해줌으로써, 라우팅을 구성할 수 있음. {BrowserRouter(전역-1): Routes(N) : Route(N)}의 계층적 관계로 구성될 수 있으며, `Route` 컴포넌트는 또한 스스로 타 Route에 대해 자식으로 요소로 혹은 부모요소로 존재하며 라우팅 path를 계층적으로 구성할 수 있음. / 해당 서비스 실습에서 진행한 `라우터 구성`은 `index.js/->루트 객체.render()`의 최상위로 렌더링 되는  `App.js`보다 상위에 `BrowserRouter` 컴포넌트를 감싸주는 것으로 시작했음. / 또한 `Routes`및 `Route`는 최상위 컴포넌트인 `App.js`에 계층적으로 구성되었음 / `components/` 및 `pages/` 디렉토리에는 view로 사용될 개별 `components`가 만들어 졌으며, 이는 `App.js`에서 import되어 각 라우터별로 적절하게 라우팅 되었음. / `data/` 디렉토리엔 review.json이 더미데이터로 만들어졌으며, 이는 `/components/Review.js`의 Review를 위한 컴포넌트에 map을 통해 적절하게 뿌려졌음. |
|-|웹트랙 금일 강의분 self리팩토링|개발: 웹프론트|[MyRepo: w4D4-self-refactor](https://github.com/ABizCho/Aihub_webTrack/tree/main/Self_Practice/week4_day4_refactor)|금일 강의중 실습한 리액트 영화 서비스 웹을 따라가다 `client/src/pages/review/`의 `Create.js`, `Detail.js`, `Update.js` 에 들어간 출력 `예시 영화 카드`와 `사용자 입력` 관련한 요소 containers에 단순한 text 변경 외의 불필요한 중복이 발생했음을 확인했음. 해당 `/review`디렉토리 내에 `/components`디렉터리를 만들어 중복 요소들을 기능별로 캡슐화시킨 `ExampleCard.js`,`InputBody.js` 로 컴포넌트화 시켜 유지보수의 용이성을 도모했음. 하지만, `InputBody.js`의 경우 타 컴포넌트들과 state를 비롯한 데이터를 주고받을 가능성이 분명히 존재하는데, 이 경우 전역 상태관리를 도입하지 않으면 계층간 전달 코드가 불필요하게 누적되어 가독성을 해칠 수 있을 것으로 에상됨. 전역 상태관리를 위한 리덕스 도입도 실습과정 중 있으니 큰 문제는 되지 않을 것으로 기대하고 있음.|
|22.07.26|웹트랙 w4D3)|개발: 웹프론트|[MyRepo: w4D3) 이벤트 핸들러, 훅, 라우터](https://github.com/ABizCho/Aihub_webTrack/tree/main/Learn/week4/Day3)|이벤트 핸들러와, 훅 및 라우터에 대해 배우며 실습함. / `이벤트 핸들러`는 이미 js에서도 충분히 다뤘던 내용이므로 생략하고자 하나 `props`로 컴포넌트 간 전달될 수 있다는 주요한 특징만 추가하면 될 듯. / `훅`은 리액트가 `클래스 컴포넌트`기반의 방식에서 `함수형 컴포넌트`를 지원하며, 기존 클래스 컴포넌트에서 직접 다루던 state 관리 등을 함수형 패러다임에 맞게 지원하게 된 새로운 방식의 기능임. 사실상 low level에서 수행되는 동작은 동일하지만 개발자 친화적인 기능이라고 생각하면 됨. `useState`, `useEffect`,`useMemo`,`useCallback`, `useRef` 등 주요 hooks에 대해 배웠으나, 가장 중요한건 `useState`와 `useEffect`임. useState는 작년에도 충분히 활용해보았고 개념을 확실히 이해하기에 useEffect를 기록하겠음. / `useEffect()`는 첫번째 인자로 콜백함수를, 두번째 인자로 `Deps`를 받음 Deps는 총 세가지 타입으로 인자 입력이 가능함/ (1) `[state(s) or Props(s)]`처럼 state(or props)를 담은 배열을 넣어주거나 (2)`[]` 빈 배열을 넣어주거나. (3)default, 즉 deps 입력을 생략할 수 있음 / `(1)`번 케이스로 특정 state or props를 배열에 넣어서 전달할 시, 해당 값들을 감시하며, 감시당하는 인자들에 변화가 생길 시 첫번째 인자로 받은 callback함수를 실행시켜줌. 즉 state(props) 변경에 따른 `side effect`를 발생시킴. / `(2)`번 케이스로 빈 배열을 넘겨줄 시, 모든 렌더링 수행마다 콜백함수를 실행시킴 -> 여기서 `모든 렌더링`이란 개념을 확실히 해야하는데, 컴포넌트 내의 특정 `state`가 변화할 시 리액트의 가상 돔은 변화를 감지하고, 해당 state와 관련한 컴포넌트 혹은 요소들에 대해 재 렌더링을 수행하게 됨. / `(3)` 만일 deps에 `default`가 들어갈 시, 즉 deps에 아무 인자도 전달하지 않을 시, `최초의 렌더링` 시에만 콜백함수를 호출함. 여기서 최초의 렌더링은 Component가 `Mount`되었다는 말과 같음. // `useMemo`및 `useCallback`은 브라우저의 메모리를 사용하여 특정한 내용을 기억시키는 방법인데, 메모리 사용의 이유로 무거운 로직을 사용해서는 절대 안됨. 대부분의 케이스에서 이런 문제가 발생할 수 있으므로 사용을 권장하지 않는다고 강사님께서 조언해주셨음. |
|22.07.25|웹트랙 w4D2)|개발: 웹프론트|[MyRepo: w4D2) props & state ](https://github.com/ABizCho/Aihub_webTrack/tree/main/Learn/week4/Day3)| props & state 를 오전까지 학습했음. `props`와 `state`개념은 작년의 자습시에도 확실하게 잡고자 노력했었음. / `props`는 리액트에서 계층적 컴포넌트 간 데이터를 주고받기 위한 전달 방법이자 개념이고, `state`는 소속한 컴포넌트 내에서 가져야 할 컴포넌트 상태 변화 관리를 위한 개념이자 방법 / `state`는 절대 직접 조작되어선 안되며, `state hook`을 위한 관리가 요구됨. 만일 해당 state를 소속된 컴포넌트의 하위 컴포넌트에서 전달받아 관리되어야 한다면, setState를 직접 전달하면 안되며, 반드시 event핸들러 등의 함수 내에 구성하여 state를 조작해줘야 함. / 앞선 설명처럼 데이터는 props를 통해 하위 계층의 컴포넌트로 이동할 수 있으며, state 또한 전달 가능하긴 함. 하지만 서비스가 커짐에 따라 컴포넌트 계층의 복잡도가 크게 증가하며, props 전달의 불필요한 중복 사용이 요구될 수 있음. 이런 불편함을 완화시켜주기 위한 방법으로 redux,recoil 등의 전역 상태관리 라이브러리가 사용 될 수 있음. 리덕스는 store 객체를 App 등 최상위 컴포넌트에 위치시켜, 전역으로 사용할 state를 스토어 내에 정의하고, 이를 export함. redux store의 state가 필요한 컴포넌트에선 이를 불러와 불필요한 state전달과정을 거치지 않고, 직접적으로 전역에서 선언된 state에 접근 할 수 있음. // 저번주 금요일 토스 특강에서 들었던 바에 의하면 토스의 경우 전역 상태관리 라이브러리에서 벗어나 react query를 이용한 상태관리로 리팩토링하는 중이라고 들었음. `react query`에 대해선 추가적인 공부가 필요해보임.|
|-|SMA 3주차 EDA수행 & DTM구성|데이터 분석: SMA|[MyRepo: week3 Directory](https://github.com/ABizCho/SMA_2022summerProject/tree/main/week3)|3주차 미팅 시작 전, Article Meta Data 데이터 프레임을 이용한 기초 EDA 분석과, Token dataframes를 이용한 워드클라우드 시각화, 그리고 DTM 구성을 진행함. 학교 빅데이터센터의 서버로 열어준 jupyter와 내 로컬 vs code에서 병렬작업하여 자료가 흩어짐. vs code에 결과물을 정리하고 문서화 시킬 필요가 있으며, 향후 정리의 용이성을 위해 양측 에디터의 디렉토리를 재구성 할 필요가 있음.|
|-|SMA 3주차 마감 미팅|데이터분석: SMA|[MyRepo: week3 Directory](https://github.com/ABizCho/SMA_2022summerProject/tree/main/week3)|3주차 마무리 미팅을 가졌음, 직전 주차 작업인 Tokenization 로직 개선과, EDA 결과 공유, DTM 구성 결과 보고 등을 발표했는데 EDA에 큰 시간을 할애하지 못해 조금 우려했던 것과 달리, 가설과 다르게 나온 EDA 결과들에 대해 교수님께서 흥미를 가져주셨음. 왜 게시자의 user_score가 최상위인 집단보다, 중간 점수대에 속하는 집단의 게시글이 더 압도적으로 높은 좋아요를 얻었는지 흥미로운 인사이트가 존재할 수 있으며 이에 대해 가능하다면 깊게 검토해보고 유의미한 결과가 있을 시 배포해 보자는 교수님의 피드백이 있으셨음. 다만, 웹트랙과 연구를 병행중이기 때문에 설정해 둔 연구의 메인 주제를 벗어난 작업들을 제시간 안에 모두 수행할 수 있을지 의문이므로 일단 두고봐야 할 것 같음.|
|22.07.25|웹트랙 w4D1) React 시작|개발: 웹프론트|[MyRepo: w4d1 리액트 기초](https://github.com/ABizCho/Aihub_webTrack/tree/main/Learn/week4/Day1)|저번주 Node.js의 Express.js 및 MongoDB(Mongoose)를 사용한 서비스 구현을 마무리했고, 오늘부로 React App 파트를 시작함. 작년말 리액트+일렉트론을 사용한 웹앱개발 경험이 있는데, 작년엔 자바스크립트나 웹 구조 및 엔진에 대한 이해가 결여된 상태에서 자습하고 맨땅에 헤딩했기에 개념이 잘 와닿지 않았고, 개별 모듈들의 의미 또한 불분명하게 느껴졌었으나 1년간 어느정도 쌓인 개발지식과 더불어 웹트랙에서 사전에 체계적으로 배운 지식들이 기반이 되어, 작년의 독학에 비해 훨씬 빠르고 정확하게 의미들이 와닿고 있음. 아직 초입에 불과하지만, 작년에 잘 이해가 가지 않던 실전 리액트 프로그래밍 책을 옆에 끼고 함께 공부하며 리액트 구조를 정확히 파악하고 개발해보리라 다짐함. // 리액트는 UI라이브러리로, 서비스 구성을 위해선 다양한 기능을 담당하는 여러 외부 라이브러리들과 함께 사용해야함. 이를 어느정도 프레임워크로 정형화해서 제공하는 방법이 create-react-app ./ 리액트 사용에는 지켜야할 새로운 규칙 몇가지가 존재. 대표적으로는 `(1)JSX사용`, `(2)className 등 camelCase사용` `(3)컴포넌트 단위 view 개발(CSR개념)` `(4) 클래스형 컴포넌트 vs 함수형 컴포넌트` 폼의 작성법 `(5)props & state` `(6)리액트 훅` 정도가 있겠음. / `(1)`의 JSX는 `createElement()`함수를 통해 비교적 가독성이 떨어지는 형태의 DOM작성 문법을 `JSX`라는 문법으로 작성하도록 지원하는 확장자인데, 개발자가 작성한 JSX를 외부 라이브러리인 `babel(바벨)`이 파싱 및 코드 변환을 해줌으로써, 리액트에는 결국 createElement를 통한 DOM구성이 되도록 해줌. / `(3)`과 `(5)`는 어느정도 밀접한 연관성이 있음. 리액트는 여러 컴포넌트가 계층적으로 구조화됨. 그리고 부모-자식의 컴포넌트간 관계에서 부모 컴포넌트가 자식 컴포넌트로 props 객체를 전달해 줄 수 있으며, 자식컴포넌트는 props객체를 인자로 전달 받을 수 있음. 만일 부모의 자식의 state에서 접근,조작,변경 할 수 있도록 하려면, 이를 조작하는 함수를 부모에서 정의해서 함수자체를 내려줘야하는게 원칙임. 그 이외에도 props 및 state 사용의 불변 원칙 등은 `실전 리액트 프로그래밍` 책을 참고하여 추가 공부할 예정|  
|22.07.24|SMA 3주차) Mecab환경 구축 및 토큰화 로직개선|개발: 웹프론트|[MyRepo: ]|학교의 빅데이터센터에서 연결받은 주피터환경에 구축된 Mecab 형태소분석기를 사용해보고, 직전주차의 Customized Konlpy의 twitter분석기와 비교해 본 결과, Mecab은 연결된 문자가 분리된 경우 개별로 토큰화 되어도 개별 토큰의 튜플들을 배열로 묶어서 반환하는 것을 확인. (word,type)의 튜플을 배열로 묶어 반환하기에, type의 연속성을 확인하고 이를 분기하여 복합명사로 가공하는 로직을 작성할 수 있었고 기존의 okt 사전 수작업 처리보다 훨씬 개선된 작업속도를 가졌음. Mecab은 기본적으로 linux환경용으로 구축됐기에 환경 구축 및 사용자 사전 사용에 애를 좀 먹었음. 사용자 사전처리는 로컬에서 먼저 돌리고, 학교 서버에서 복합명사 처리로직을 돌려서 처리속도를 높일 예정임|
|22.07.22|웹트랙 w3D5) 기능추가: 권한제어,패스워드 변경,이메일|개발: 웹프론트|[MyMd: 5일차 auth관련 개발노트](https://github.com/ABizCho/Aihub_webTrack/blob/main/Learn/week3/Day4/prac1_servicePJ/note2_day5_auth.md)|jwt로 로그인 시 access Token을 발급하고 그에 따라 authMiddleware를 통해 검증 및 권한 제어를 구현함. / 또한, 단일 access Token이 가진 보안 취약점(탈취)을 배우고, refresh Token과의 차이와 보안 취약점 보완 원리를 이론적으로 학습함./ authMiddleware을 작성, app객체의 posts경로 전체에 라우팅 되기 전 미들웨어가 동작하도록 설정함. / ajax 요청 시 클라이언트단의 브라우저에 저장해 둔 쿠키 저장소에서 accessToken을 가져와 클라 -> 서버로의 ajax 요청 헤더에 토큰을 넣어 보냄. 서버는 이를 검증해 옳은 token일 경우, 그에 맞는 응답을 보냄/ 패스워드 분실 시, 난수로 패스워드를 생성하여 가입시 메일주소에 메일을 전송하는 것을 구현.|
|-|self Prac Todo 체크박스 checked 동적 변환 질문|개발: 웹프론트|-|DB에 저장된 todo document의 isDone(boolean)값에 따라, 체크박스를 가진 리스트 그룹을 템플릿 리터럴로 구성하여 view로 뿌려줄 때, checked attribute를 어떻게 동적으로 반영할 지 어제 새벽 연습해보며 고민하다가 오늘 강사님께 질문함. / 적어도 내가 찾아본 바로는 jQuery의 선택자로 html에 접근하는 방법밖에 없었음. 하지만 해당 방법은 우선 템플릿 리터럴을 view에 뿌려준 후, 그 html doc의 element를 다시 가져와서 작업하는 것으로 변경되는 모습이 사용자에게 보일 것이라는 생각이 들어 완벽한 답이 아닐것이라고 판단. 이와 관련해 질문했는데, 근본적으로 Node.js환경만으로는 if-else로 다른 템플릿 리터럴로 html 돔트리를 구성해두고 보내는 것이 베스트라고 해주셨음. 다만 리액트에선 오히려 이런 방법이 비효율로 작용하므로, 다르게 지원되는 방법을 사용한다고 말씀하셨음. 조건분기를 방법을 반영해서 지금 당장 수정해볼 예정임|
|22.07.21|웹트랙 w3D4) MongoDB & Express.js 서비스 ~ 회원가입,로그인,JWT인증|개발: 웹프론트|[MyRepo: 서비스 구현~ 로그인,회원가입,jwt](https://github.com/ABizCho/Aihub_webTrack/tree/main/Learn/week3/Day3/prac1_servicePJ) / [MyMd: JWT 정리](https://github.com/ABizCho/Aihub_webTrack/blob/main/Learn/week3/Day3/note3_jwt.md)|User관련 컬렉션으로 회원가입을 구현하고, 로그인 및 jwt를 이용한 AccessToken 발급 및 검증까지를 배우고 구현했음. jwt에 대한 이해를 위해 수기노트로 시각화 정리했음. 쿠키를 이용하기 위해, 직접 설계하지 않고 jquery의 cookie cdn을 사용했음.|-|개인 Practice서비스 Todo 웹 시작|개발: 웹프론트|[MyRepo: my Node.js todo prac service](https://github.com/ABizCho/Aihub_webTrack/tree/main/Self_Practice/week3_pracWeb)|웹트랙 3주차에서 지금껏 배운 Express.js 및 MongoDB를 활용한 MVC 패턴의 웹 서비스의 구조를 복습해볼 겸, 직접 쌓아올려보기 위해 TODO리스트를 목표로 SELF PRACTICE를 시작함. DB연동하여 프론트에 리스트 다큐먼츠들을 구성하여 뿌려주는 것까지 구성. 하지만 저장된 isDone(boolean)에 따라 체크박스에 checked attr를 제어해 뿌려주는 것에서 막혀서 다음날 강사님께 질문드림|
|22.07.20|웹트랙 w3D3) MongoDB & Express.js 서비스 ~ CRUD|개발: 웹프론트|[MyRepo: prac1_servicePJ](https://github.com/ABizCho/Aihub_webTrack/tree/main/Learn/week3/Day3/prac1_servicePJ)| 어제자로 시작된 몽고DB + 익스프레스 서비스 구현 PRAC를 발전시켜 CRUD기능이 완성됨. 다시한번 구조를 되짚어보고 이론을 복습해봐야겠음. 오늘 강사님께서 전체적인 동작을 설명해주셔서 다시한번 정리하자면, 우리가 구현중인 CSR(클라)방식은 크게는 [DB,서버,클라,브라우저]의 총 네 참여자가 존재하며 / (1) 사용자가 브라우저에 url 요청 시, 가장 먼저 `클라이언트`가 html을 `브라우저`에 응답하고 / (2) `브라우저`는 `${document}.ready(..logic)`등의 코드로 html이 준비됨을 확인하여, 뿌려져야 할 `데이터`를 `서버(express)`에 ajax로 요청함 / (3) ajax요청을 받은 `서버`는 라우터로 사전에 요청-응답으로 정의한 동작(미들웨어)들을 수행하며, DB에 데이터를 요청하고, 응답받은 데이터를 다시 구조화하여 브라우저에 응답해줌.// 해당 요청-응답 프로세스에서 각 참여자들은 고유의 PORT들을 사용하며 필요에 따라 요소간 PORT로 연결됨 (8080, 27017, ...등)|
|22.07.19|웹트랙 w3D2) MongoDB & Express.js 서비스 구현|개발: 웹프론트|[MyRepo week3-Day2 Dir](https://github.com/ABizCho/Aihub_webTrack/tree/main/Learn/week3/Day2)|몽구스와 express.js를 이용한 간단한 서비스 구현을 위한 프로젝트 실습. MVC패턴으로 `models`,`routes`,`view`를 루트에 위치시키고 각각의 구조를 이해하며 바닥부터 쌓아올리는 연습을 해보았음. 서버는 nodemon 의존성을 추가하여 상시가동시켰으며 package.json에 npm start 명령어 동작으로 지정해두었음|
|-|SMA 2주차 마감 미팅|데이터분석: SMA|[SMA 2주차 Tokenization 업무관련 dir](https://github.com/ABizCho/SMA_2022summerProject/tree/main/week2)|2주차 예정 TASK인 Tokenization 관련 작업사항 및 산출물을 정리하여 미팅에서 교수님께 PR했음. 약 100만개 이상의 데이터 크기로 로직 수행의 런타임이 너무 길어지는 어려움이 있어 공유드렸고, 학교 랩실서버의 빅데이터서버 담당자분을 컨택시켜주셔서 관련 서버로 연결된 주피터환경을 사용할 수 있도록 도와주셨음. 추가적으로 BERT가 구축되어 있어서, 예정된 감성분석에도 도움을 얻을 수 있을것으로 기대함| 
|22.07.18|웹트랙 w3D1) MongoDB와 Mongoose|개발: 웹프론트|[MongoDB와 Mongoose이해](https://github.com/ABizCho/Aihub_webTrack/blob/main/Learn/week3/Day1/note1_mongoDB.md)| MongoDB는 대표적인 NoSQL, Document DB로 대용량 데이터를 처리하기 좋게 만들어졌음./ NoSQL은 (Non SQL, Not Only SQL)로 다의적으로 해석됨. RDB와 다르게, 자료간의 관계에 초점을 두지 않으며, 구조화된 쿼리를 사용하지 않음. 당연히 기본적으로는 데이터를 구조화 하지 않고 유연하게 저장함. 하지만 간단한 수준의 구조화는 저장의 용이성으로 사용될 수 있음. 이런 유연성으로 DDL(데이터구조화)없이도 사전작업을 건너뛰고 DB사용이 가능하며, 프로젝트의 빠른 진행이 가능함. NoSQL은 다양한 종류가 있으나, 대표적으로는 자료를 Document로 저장하는 Document DB가 있음. / MongoDB는 [ DB > Collection(s) > Document(s) ] 의 계층적 구조로 구성됨. / `DB`는 하나 이상의 collection을 가질 수 있는 최상위 계층의 저장소임. / `Collection`은 하나 이상의 Document(s)가 저장되는 공간으로, SQL의 table과 유사함. 하지만 collection이 document 구조를 정의하지는 않음. / `Document`는 MongoDB에 저장되는 자료의 가장 저수준의 기본단위임. SQL에서의 row와 유사한 개념이지만, 구조제약 없이 유연한 저장이 가능함. JSON과 유사한 BSON알 사용해 다양한 자료형 표현,저장을 지원함. objectID는 각 document의 유일한 키 값으로, SQL의 Primary Key 개념이며. 하나씩 증가하는 값이 아니며 document를 생성할 때 MongoDB의 내장함수를 통해 자동으로 생성되는 해쉬?(혹은 유사) 값이 할당됨 // `MongoDB Compass`는 GUI를 지원하는 앱 형태로 DB,컬렉션,다큐먼트 등을 시각화된 대시보드로 관리할 수 있게 도와주는 도구임. MySQL의 워크벤치와 유사한 개념. // `Mongoose ODM`이란 Object Data Modeling의 준말로, MongoDB의 cOLEECTION에 집중해 관리하도록 도와주는 패키지 개념임. collection을 모델화해, 관련 기능들을 쉽게 사용할 수 있도록 도와줌. / 관련 기능으로는 (1)연결관리, (2)스키마관리, (3)Populate(join유사기능) 을 지원함. / 몽구스 ODM을 사용하기 위해 MVC패턴에 입각해 구조화된 프로젝트 디렉터리에서, 스키마를 정의하고, 모델을 만들고(작성), DB를 연결하고, 작성한 모델을 사용해 CRUD기능을 수행할 수 있음. CRUDE를 위해 [create / find,findById, findOne / updateOne, updateMany... / deleteOne, deleteMany...] 등의 관련 함수(메서드)가 사용됨 // MongoDB에도 SQL의 where과 유사한 조건절을 사용할 수 있으며 query는 BSON형식으로 지원하며, 해당 쿼리문법 그대로 몽구스에서도 사용할 수 있음|
|-|웹트랙 w3D1) Express.js + Mongoose ODM|개발: 웹프론트|[MyMd: Express.js + 몽구스ODM](https://github.com/ABizCho/Aihub_webTrack/blob/main/Learn/week3/Day1/note2_expressMongoose.md) / [Express.js + MongooseDB 실습](https://github.com/ABizCho/Aihub_webTrack/tree/main/Learn/week3/Day1/ex1_expressMongoose)|Express.js는 프로젝트 구조를 자유롭게 구성 가능함, 어느부분에 Mongoose ODM을 위치시키면 좋을지 적절한 위치 선택이 중요함. / 일반적으로 EXPRESS 프로젝트의 models 디렉토리에 `schemas/`와 `model(= index.js)`을 함께 위치시킴, schemas 디렉 내에서 mongoose.Schema 들을 정의하며, `models/index.js`에서 mongoose.model을 선언하여 스키마 정의들을 모두 불러모아 export하게 됨.
|22.07.17|SMA 2주차 NLP Tokenization|데이터분석: SMA|[week2-Tokenization 수행 Dir](https://github.com/ABizCho/SMA_2022summerProject/tree/main/week2) / [week2 outputs](https://github.com/ABizCho/SMA_2022summerProject/tree/main/outputs/week2)|1주차 최종 결과물로 스크래핑 데이터를 dataframe형식으로 담은 ['df3_2_artsClean.csv'](https://github.com/ABizCho/SMA_2022summerProject/blob/main/outputs/week1/df3_2_artsCleanEtc.csv)의 art_title, art_content, art_comments 컬럼 내 string 데이터들을 형태소 word단위로 Tokenization하고 각 word들을 소속했던 article_id와 매칭하여 저장한 새로운 파생 df 테이블을 결과물로 만들었음. / 기존 df3_2_artCleanEtc는 약 15000개의 article을 기준으로 해당 갯수의 records가 있었음. 결과물로 title word테이블은 은 토큰화된 각 word를 row구분 기준으로 70000개의 records를 가지게 됐고, content wordset테이블은 약 100만개의 records를 저장했음. comments의 경우 약 10시간의 처리 및 저장 런타임에도 절반도 처리하지 못하여 포기했고 결과 레코드는 200만개 이상의 수로 추정됨. / 과도한 데이터 크기로 인해, 런타임이 기하급수적으로 늘어나 반복적으로 수행해야 할 [복합명사 사전추가, replace로 다형 키워드 통일화] 작업을 완벽히 수행하지 못했으며, bi-gram으로 수행하고자 했던 복합명사 처리 로직 또한 너무 긴 런타임이 예상돼 수작업으로 대체하기로 결정. / + 2주차 마감 회의 중 교수님께 데이터 크기로 인한 향후 Task의 처리시간 문제를 문의드려서, e-biz서버로 구축한 lab server를 공유받을 수 있었음|
|22.07.15|웹트랙 w2D5) Express 미들웨어|개발: 웹프론트|[MyMd: Express 미들웨어](https://github.com/ABizCho/Aihub_webTrack/blob/main/Learn/week2/D5_Express_RESTAPI/note1_middleware.md)|미들웨어는 Express.js의 동작 핵심 요소. HTTP 요청과 HTTP 응답 사이에서 단계별 동작을 수행해주는 함수./ Express의 미들웨어 동작은 HTTP request가 들어온 순간부터 시작되며 미들웨어 간 response,request,next를 인자로 HTTP요청과 응답객체를 처리하거나 다음 미들웨어를 실행하는 등의 동작을 수행함. HTTP 최종 응답이 마무리될때까지 미들웨어 처리 프로세스상의 미들웨어 사이클이 단계별로 수행됨 / 미들웨어는 req,res,next를 인자로 가진 함수를 작성하여 동작시킴. / req는 HTTP요청을 처리하는 객체로 (1)url path parameter변수로 url형식의 요청을 파싱하는 방식 => req.params  (2)req.query : query string 방식으로 데이터를 입력받는 방식, 대표적인 두가지 방식으로 데이터를 받음 / res는 req객체에서 받은 데이터를 처리하여 HTTP 응답을 보낼 수 있는 객체로 res.send(), res.json() res.render() 의 대표적 메서드들을 사용해 응답을 처리함. res.json()은 단순히 데이터를 json형으로 묶어주고 send하는 메서드로, 내부적으로는 말미에 res.send()를 수행함|
|-|웹트랙 w2D5) REST API 이해|개발: 웹프론트|[MyMd: REST API](https://github.com/ABizCho/Aihub_webTrack/blob/main/Learn/week2/D5_Express_RESTAPI/note2_RESTAPI.md)|API란 (Application Programming Interface)의 준말로 서비스나 프로그램 간에 미리 정해진 기능을 실행할 수 있도록 정해둔 규약을 말함. 종류로는 운영체제 API, 프로그램언어 API, 웹 API 등이 있음./ REST API는 REST 아키텍처를 준수하는 웹 API를 말함. 여기서 REST란 (REpresentational State Transfer)의 준말로 웹에서 자료를 전송하기 위한 표현방법에 대한 아키텍처를 말함. REST를 정확히 구현하기 위해선 많은 조건을 준수해야하지만, 기본적 REST가이드를 따르면 좋은 구조의 API를 만들 수 있음 / REST API는 API의 동작을 `HTTP메서드`+`명사형URL`로 표현함, 이를 위한 추가적인 기본 가이드 세가지가 있음. / (1)URL 표현법: REST API URL의 자원은 `복수형`으로 표현됨. 특정 컬렉션 전체를 지정할 땐, 복수형 명사로(`/posts`). 컬렉션의 특정 요소를 지정할 땐, [복수형 자원명사 / 아이디]로 (`/posts/1`)와 같이 지정함. / (2)HTTP 메서드의 사용: GET,POST,PUT,DELETE 등의 HTTP메서드와 url자원을 결합해 API동작을 정의해야 함 / (3)계층적 자원표현: REST API는 URL 자원을 계층적(순서)으로 표현하여 지정할 수 있음. `users/1/posts`라는 url은 `유저-1번`의 `게시글 전체`라는 자원을 지정하는 계층적 표현임|
|-|웹트랙 w2D5) json의 이해|개발: 웹프론트|-|JSON이란 javascript에서 객체를 표현하는 표현식으로 시작된 개념으로, 지금에 이르러서는 그 간결성으로, 웹 API에서 데이터를 전송할 때 사용하는 표현식으로 주로 사용되는중. / 웹 API는 기본적으로 데이터를 `문자열`로 전송하는데, 어떤 객체를 웹 API를 통해서 문자열로 전달하기 위해 JSON을 사용하는 것. JSON은 적은 표현식을 사용, 데이터를 효과적으로 구조화하여 표현함 / JSON에서 Obejct는 {key: value}로 표현함. value에는 문자열,숫자,하위 JSON객체 등 어떤 값이라도 들어갈 수 있음 / JSON에서 Array는 [item1,item2]의 모습으로 표현하며 item에는 어떤 값이든 자유로이 혼재되어 들어갈 수 있음|
|22.07.14|웹트랙 w2D4) 웹 동작 이해|개발: 웹프론트|[MyMD: Web동작 이해](https://github.com/ABizCho/Aihub_webTrack/blob/main/Learn/week2/D4_Web_ExpressJS/note1_web.md)|Web은 실질적 의미로는, 웹브라우저로 접속해 이용하는 서비스,웹사이트임. / 웹 서비스는 기본적으로 `HTTP 요청-응답`의 반복으로 구성됨. / [Process] : (1)사용자가 브라우저에 url을 입력하는 등 html을 요청. (2)브라우저가 인터넷을 통해 사용자가 요구한 HTTP요청을 서버에 전달. (3)서버는 HTTP응답을 브라우저로 전송 (4)브라우저는 HTTP응답을 사용자에게 적절한 화면으로 노출(응답 시각화) / HTTP 요청과 응답은 다르게 생겼음(담고있는 정보가 다름)/ 프론트,백엔드, 정적-동적웹 개념을 배움 / 동적웹은 프론트엔드와 백엔드의 역할분담 비중에 따라 CSR,SSR로 나뉨 CSR이 자연스러워 현재로선 지배적./ SSR은 서버(백엔드)에서 html페이지 자체를 통으로 렌더링해서 클라이언트로 쏴줌. 페이지 자체가 새로 로드되는 방식으로 비효율,부자연스러움|
|-|웹트랙 w2D4) 웹 프레임워크 이해|개발: 웹프론트|[MyMd: 웹 프레임워크](https://github.com/ABizCho/Aihub_webTrack/blob/main/Learn/week2/D4_Web_ExpressJS/note2_webFramework.md)|웹프레임워크란 웹서비스 구성에 필요한 기능들을 종합적으로 지원,제공해주는 다양한 도구들의 모음./ 기본 구성요소: (1)HTTP요청처리 (2)HTTP응답처리 (3)라우팅 (4)HTML Templating / 라우팅은 HTTP요청을 알맞은 동작(응답)으로 분기하는 방법을 제공함, 템플레이팅은 SSR을 구현하기 위한 방법을 제공하는 것으로, 응답으로 보낼 HTML을 서버에서 작성하기 위해, HTML Template를 통해 미리 페이지의 뼈대를 만들 수 있도록 함./ Node.js 생태계에는 대표적으로는 Express.js부터 Koa.js, Nest.js등의 다양한 웹 프레임워크가 있음|
|-|웹트랙 w2D4) Express.js 웹 프레임워크|개발: 웹프론트|[MyMd: Express.js](https://github.com/ABizCho/Aihub_webTrack/blob/main/Learn/week2/D4_Web_ExpressJS/note3_Express.js.md) / [MyRepo: D4_Web_ExpressJS](https://github.com/ABizCho/Aihub_webTrack/tree/main/Learn/week2/D4_Web_ExpressJS)|Express 구축 절차: (1)npm init으로 npm프로젝트 환경 구축 (2)express 패키지 install(의존성 추가) (3)프로젝트 루트에 index.js든 app.js든 만들고 express() 생성자로 app이라는 변수명으로 express 객체 인스턴스 할당 후, app.use()를 사용-express인스턴스에 미들웨어, 라우터 등 바인딩, app.listen()로 포트 할당 후 서버 실행 등의 동작 정의 (3) MVC패턴에 따라 Model, View, Controller(=routes) 구조의 디렉 및 동작, 소스 설계 // 또한, express-generator 패키지(의존성)을 통해 손쉽게 프로젝트 생성 가능. 이에 더해 npx로 설치없이도 express-generator로 PJ설계 가능 / express의 라우팅엔 두가지 방식 존재, app(express 객체 인스턴스)를 이용한 라우팅 과 express.Router()로 생성한 router객체의 라우팅 방식 있음. 전자의 app 라우팅은 라우팅의 핵심인 그룹화 기능을 지원하지 않지만, 후자의 라우터 router객체에선 라우팅을 모듈화하여 그룹화 사용 가능함. 라우터는 일반적으로 앞에서 언급한 방식처럼 파일별 모듈화시켜 import/export하여 사용함. router.use()처럼 라우터 객체도 하위 라우터를 use함수로 연결해 사용 가능함.|
|22.07.13|웹트랙 w2D3) NPM, NPX|개발: 웹프론트|[MyMD w2D3 NPM 정리](https://github.com/ABizCho/Aihub_webTrack/blob/main/Learn/week2/w2_D3_NPM_NodeJS/w2D3_1_NPM.md) / [MyMD w2D3 NPX 정리](https://github.com/ABizCho/Aihub_webTrack/blob/main/Learn/week2/w2_D3_NPM_NodeJS/w2D3_2_NPX.md)|NPM이란 Node.js 프로젝트를 관리하는 필수적 도구임. Node Package Manager의 약자. 온라인 저장소와 커맨드라인 도구 두가지 기능. 커맨드라인 도구는 PJ관리를 위한 라이브러리 설치, PJ 설정관리, 의존성 관리 기능 지원. / 패키지는 로컬 패키지, 전역 패키지로 구분되며, 로컬은 PJ내의 package.json에 선언되어 있고 node_modules 디렉토리에 저장됨. `npm run`명령어로 package.json의 scripts에 선언된 간단한 동작 수행 가능. / NPX는 설치 없이 패키지 내의 모듈을 바로 사용할 수 있도록 명령어로 지원함|
|-|웹트랙 w2D3) NodeJS 모듈|개발: 웹프론트|[MyMD w2D3 Node.js 모듈 정리](https://github.com/ABizCho/Aihub_webTrack/blob/main/Learn/week2/w2_D3_NPM_NodeJS/w2D3_3_NodeJS_Module.md)|모듈이란 기능에 맞게 코드를 분리 및 재사용하는 방법임. import export를 기본으로 내보내기, 불러오기로 사용. / 패키지란 모듈의 모음임 npm 패키지들은 많은 모듈을 포함하고 있는 코드 모음./ Node.js의 기본 제공 모듈은 [`console`,`process`,`fs`,`http`,`url`,`os`,`Path`,`crypto`] 등의 모듈이 존재함. / npm으로 Node.js 모듈을 import하고 사용할 수 있을 뿐 아니라 직접 작성 활용 가능./ JS에서 자체적으로 지원하는 ES Module이 나왔음. 이는 Node.js의 commonjs모듈의 문법과 기본적 동작 방식이 다르므로 혼용은 좋지 않음|
|22.07.12|SMA 1주차 마감 미팅|데이터분석: SMA|[SMA 1주차 TASK1 스크래핑 MD](https://github.com/ABizCho/SMA_2022summerProject/blob/main/docx/w1_scrapping.md)/[SMA 1주차 TASK2 기초 텍스트 정제 MD](https://github.com/ABizCho/SMA_2022summerProject/blob/main/docx/w2_basicNLP.md)|1주차 마감과 2주차 시작 점검회의를 7월12일 오후 7시에 가졌음. OKKY스크래핑 요청 및 윤리준수에 관해서 교수님께서 피드백해주셨는데, 네이버와 같은 우량서비스는 공동연구서를 제출하는 등의 어려움이 있을 수 있다는 주의점을 주셨음. 또한 마크다운 등 깃허브에 정리하는 습관을 좋게 평가해주셔서 앞으로도 이어나갈 예정|
|-|웹트랙 w2D2) NodeJS와 ES6, 비동기, EventLoop|개발: 웹프론트|[MyRepo w2D2 디렉토리](https://github.com/ABizCho/Aihub_webTrack/tree/main/Learn/week2/w2_D2_NodeJS_MongoDB)| NodeJS와 ES6에 대해 배웠음. NodeJS는 싱글 스레드로, 비동기와 이벤트 기반으로 동작함. 싱글 스레드는 스레드 수가 하나로 리소스 관리에 효율적이나, 스레드 기반 작업들의 효율이 떨어짐-> 그래서 Node.js는 비동기 동작을 기본으로 스레드 기반 작업을 최소화시키며 이를 위해 이벤트루프를 활용함 / ES6 는 ECMAScript라는 js 표준문법의 버전 중 하나로, ES6는 현대적 문법을 가진 버전임. 현대적 문법의 활용은 가독성과 간결성을 비약적으로 높이므로 적극적으로 사용할 필요. (1) let, const : 상수와 변수의 구분  (2) Template literal(string)  (3) 화살표 함수, 익명 함수 (4) class : 일반적 형태의 클래스 지원 (5) 비구조화 destructing : 배열, obj의 비구조화 지원 (6) 비동기 API : 콜백, Promise, await/async : 콜백지옥, 프로미스 지옥을 거쳐 나온 것이 가장 많이쓰이는 await, async 비동기 문법임 |
|22.07.11|웹트랙 w2D1) PJ 첫회의 & 조직구성, 문서 작성|개발: 웹프론트|[inSSA-food Repo](https://github.com/inSSA-food-repository/inssa-food-client)|첫 회의에서 AI활용 웹 서비스 주제선정(INSSA-FOOD), 문서작성 등을 수행|
|22.07.10|SMA 1주차 Scrapping 로직 구현|데이터분석: SMA|[MyMd: SMA W1 스크래핑 문서](https://github.com/ABizCho/SMA_2022summerProject/blob/main/docx/w1_scrapping.md)|스크래핑 로직을 작성하고 각 단계별 산출물 저장, 1주차 Markdown 작성까지 완료했음|
|22.07.09|SMA 1주차 scrapping test code 작성|데이터분석: SMA|[MyRepo: scrapping code](https://github.com/ABizCho/SMA_2022summerProject/blob/main/analysis1_scraping.py)|1주차 okky사이트 스크래핑 코드 작성 및 테스트 진행 중, 저장 및 요소추출 코드 추가 요망|
|22.07.08|웹트랙-w1D5) 비동기|개발: 웹프론트|[Mymd: w1D5 js비동기](https://github.com/ABizCho/Aihub_webTrack/blob/main/Learn/week1/w1_D5/w1D5_1_async.md)|JS엔진은 기본적으로 메인스레드 하나로 동기처리, 비동기 처리를 위해 관련 API [setTimeout, Ajax함수, Promise 등]를 제공함. / JS 실행 구조는 ['콜스택', '잡큐', '태스크큐', '이벤트루프']로 구성/ JS 엔진의 메인 스레드는 콜스택 사용하여 동기코드를 순차처리, 즉시 처리가 불가한 비동기API는 큐에 따로 빼서 비동기명령을 처리하고, 이벤트루프가 스택의 코드가 모두 처리됐는지를 확인하여 비었을 때 큐의 비동기 콜백을 스택으로 옮겨 처리함. 큐에서도 Job큐는 1순위, Task큐는 2순위 로 처리함/ Job큐는 [ Promise, await/async ]를 담으며 Task큐는 [setTimeout, setInterval]을 담당. 각 Promise, await/async, setTimeout 등에 대해선 Mymd 참고|
|-|웹트랙-w1D5) HTML & Node.js|개발: 웹프론트|[Mymd: w1D5 Http, REST API](https://github.com/ABizCho/Aihub_webTrack/blob/main/Learn/week1/w1_D5/w1D5_2_httpRestAPI.md)|HTML은 웹상의 클라<->서버 간 통신 규약 / 클라는 서버로 요청을 보냄, 서버는 클라의 요청에 응답하며 클라 요청 전엔 대응없음/ 클라와 서버 사이 Web=[proxy, DNS, Tunnel..] 등 무수히 많은 요소 존재하며 HTTP가 이런 존재들 사이의 통신 방법을 규정함 / Message는 [요청/응답]을 의미, 요청메시지와 응답메시지는 다르게 구성됨/ Http status: Http 요청 시, 클라이언트는 요청 결과에 대한 상태 정보(200,400,500.. + Text)를 얻으며 코드를 이용해 각 결과에 해당하는 대응행위 가능/ 요청 메서드: [GET,POST...]등 HTTP에서 클라이언트는 서버로 어떠한 방법으로 요청을 보낼 지, 어떻게 응답,동작할 지 규정되어 있음/ REST API는 HTTP와 클라이언트 간 통신 구조가 지켜야 할 좋은 방법을 명시한 것, 구체적으로는 요청 메서드 의미, URI설계, 클라 상태의 동작 등 명시/ GET: 읽기, POST: 쓰기 -POST는 로그인으로 대표됨|
|22.07.07|웹트랙-w1D4) 변수 정의과정 & Hoisting|개발: 웹프론트|[Mymd: w1D5 JS실행, 실행 컨텍스트, Hoisting, js내장객체](https://github.com/ABizCho/Aihub_webTrack/blob/main/Learn/week1/w1_D4/w1D4_1_jsRun_Hoisting_JSobj.md)|JS 실행과 구조, 실행 컨텍스트 생성과 스코프, Hoisting, js내장객체 에 대해 배우고 정리했음.|
|-|reduce, map, filter 등 배열 메서드 추가학습|개발: 웹프론트|[MyNote: Array 메서드: map, filter](https://velog.io/@he1256/Extend-w1D4-map-%EB%B0%B0%EC%97%B4array%EB%A9%94%EC%84%9C%EB%93%9C) / [MyNote: Array 메서드: reduce](https://velog.io/@he1256/Extend-w1D4-map-reduce-%EB%B0%B0%EC%97%B4array-%EB%A9%94%EC%84%9C%EB%93%9C-%EB%91%90%EA%B0%80%EC%A7%80)|js의 Array 내장객체의 메서드 map, filter, reduce에 대해 추가적으로 공부 및 정리했음|
|22.07.06|웹트랙 1주 3일차 오전|개발: 웹프론트|[MyRepoL 2022Sum AI허브 웹 1주차 D3](https://github.com/ABizCho/Aihub_webTrack/tree/main/Learn/week1/w1_D3)|js는 싱글 스레드 방식으로 스택에서 실행코드 동작, 대기열 큐에 setTimeout, Ajax, 이벤트 리스너 등의 비동기 코드동작을 대기시켰다가 선행 코드가 스택에서 실행완료시 대기열큐에서 스택으로 옮겨 실행시키는 방식이며, 변수 등이 저장되는 스코프 공간은 Heap구조로 되어있음. / [this, variable object, scope chain]을 실행 컨텍스트라고 하며 이들은 처음엔 항상 초기화됨,'전역 실행 컨텍스트', 초기화 시 각각 순서대로 [ windows(최상단:글로벌을 this로 잡음), {}, [] ] 가 저장됨. 이후 함수 호출 등 동작 수행 시, 새로이 갱신되는 구조.|
|-|화살표 함수의 this|개발: 웹프론트|[웹트랙 w1D3: 화살표 함수의 this](https://github.com/ABizCho/Aihub_webTrack/blob/main/Learn/week1/w1_D3/w1_D3_context.md)|일반 메서드의 this는 메서드를 호출한 객체 그 자신을 가리키지만, 화살표 함수의 this는 자신보다 한단계 상위를 대상으로 가리킴 / 첨부된 예제의 경우 메서드 소유자 객체 o의 한단계 상위로 나가면 최상위(글로벌)이므로 this가 윈도우를 가리키게됨.|
|-|백준 2751 수 정렬 2 O(NlogN) - 퀵|개발: 알고리즘|[MyAL: 2751 O(NlogN)정렬 퀵 풀이](https://github.com/ABizCho/py_algorithm/blob/main/Solved_BJ/P11_SORT/solved_2751_sortNum2.py)|2751 수정렬3을 퀵 정렬을 이용해 풀어 O(NlogN)을 만족시킴|
|-|JS 각종 메서드 정리|개발: 웹프론트|[My: AI양재허브 웹트랙](https://velog.io/@he1256/series/AI%EC%96%91%EC%9E%AC%ED%97%88%EB%B8%8C-%EC%9B%B9%ED%8A%B8%EB%9E%99)|parseInt,Float() , slice,splice(), 아스키변환, split,join(), JSON.stringify() 메서드 등 수업시간 중 등장했던 생소한 메서드들을 조사하고 학습 및 정리했음|
|22.07.05|웹트랙 1주 2일차 오전|개발: 웹프론트|[MyRepo: 2022Sum AI허브 웹 1주차 D2](https://github.com/ABizCho/Aihub_webTrack/tree/main/Learn/week1/w1_D2)|오전 수업으로 네비게이션바 구현과 이미지 슬라이드 기능 구현을 배우고 실습. setInterval()함수와 xx.animate()메소드를 사용 / querySelector는 [id,class] 등의 선택자를 기준으로 단일 요소를 우선선택 기준으로 가져옴 ,반면 querySelectorAll은 다중선택자로 배열로 요소를 반환/ window.scrollTo() 윈도우메서드는 behavior를 동작, top을 타겟좌표 프로퍼티로 가지는 객체를 파라미터로 동작 스크롤동작을 수행함|
|-|웹트랙 1주 2일차 오후|개발: 웹프론트|-|오후엔 크로켓 사이트 기능 구현의 나머지 기능들로 [탭, 버튼형 이미지 슬라이더]를 구현했음, 추가적으로 jQuery와 json 을 학습하고 checkbox예제 또한 수행함. 동기형의 코드와 강사님의 코드를 함께 비교해가며 참 다양한 방식의 구현이 가능하구나 체감함. 타인의 코드를 비교, 참고하는 것이 발전에 큰 도움이 되는 것을 느껴 앞으로도 지속할 예정. + 코드를 컴팩트하고 설명력있게 작성하는 것을 신경쓰게 됨|
|-|SMA 연구 1주차 전체회의|데이터분석: SMA|[[MyRepo: 2022 SMA Summer PJ](https://github.com/ABizCho/SMA_2022summerProject)|교수님 주최의 연구원 전체 회의를 통해 처음으로 개인 및 주제 소개, 주차별 간단한 계획을 나누는 시간을 가짐. 내 주제와 계획에 관해 별다른 피드백이나 문제가 없다고 하셨으나, 감성 분석을 간단하게라도 더해보는 것은 어떤지 제안 해주셔서 이를 추가기획 및 수행 할 예정임.|
|22.07.04|웹트랙 궁금증: Element와 요소노드의 포함관계|개발: 웹프론트|[MyRepo: 2022Sum AI허브 웹 1주차 D1](https://github.com/ABizCho/Aihub_webTrack/tree/main/Learn/week1/w1_D1)|노드 선행학습 중 궁금한 점. HTML문서 내 모든 요소는 요소노드라고 했음. 요소=요소노드 라고 생각했는데, 뒤의 속성노드 접근예시를 보면, getEl.. 메서드를 사용해 요소를 선택하고 그것의 자식노드를 firstChild 프로퍼티를 통해 더 깊게 접근한 것을 보았는데 getEl 메서드나 노드 지정선택이나 모두 노드요소를 선택하는게 맞는지? = 동일하게 요소에 접근하는 것이 맞다는 답변을 받았음|
|-|웹트랙 1주차_월|개발: 웹프론트|[MyRepo: 2022Sum AI허브 웹 1주차 D1](https://github.com/ABizCho/Aihub_webTrack/tree/main/Learn/week1/w1_D1)|첫날 과정으로 DOM, JS와 DOM구조, 이벤트 등에 더해 추가실습을 수행했음|
|22.07.03|선택, 삽입, 버블 정렬 구현 복습|개발: 알고리즘|백준 2750|선택, 삽입, 버블을 이용한 풀이 구현을 복습했음|
|-|SMA 프로젝트 주차별 연구 계획서 작성|데이터분석: SMA|[SMA 주차별 계획서 MarkDown](https://github.com/ABizCho/SMA_2022summerProject/blob/main/docx/2_Analysis_weeklyPlan.md)|7.4~8월까지의 연구 주차별 계획서를 작성했음|
|22.07.02|카운팅 정렬(계수정렬) 개념 추가 복습 및 구현|개발: 알고리즘|[24강 계수 정렬, 동빈나](https://www.youtube.com/watch?v=65Ui3RNibRA) / [내구현: 카운팅 정렬](https://github.com/ABizCho/py_algorithm/blob/main/Learn/sort/sort4_counting.py)| 카운팅 정렬의 개념을 추가 복습하고, 이를 코드로 구현했다. 카운팅 정렬은 기존 정렬의 성능 한계점인 O(nlogn)을 극복하여 O(n+k)의 시간 복잡도를 가진다. 하지만 O(n+k)의 공간 복잡도를 가져 한계점이 있는데, 키값의 범위 전체(최소~최대) 사이 값 전체를 인덱스로 취하여 빈도를 저장하므로 양극단에만 카운팅이 몰리는 경우 혹은 과하게 넓은 도메인 범위를 가진 대상을 정할 경우 메모리를 과도하게 초과할 수 있다는 문제점이 존재.| 
-|Merge Sort(병합정렬) 개념,원리 추가 복습|개발: 알고리즘|[병합정렬(Merge Sort) 구현하기](https://www.youtube.com/watch?v=QAyl79dCO_k)|병합정렬 알고리즘은 분할-정복을 이용하여 순환적으로 구현함 n개의 데이터에 대해 logn의 분할 길이를 가지므로 O(nlogn)의 시간복잡도| 
|-|AI양재허브 웹트랙 1주차 예습|개발: 웹프론트|AI양재허브 웹 트랙 1주차 선행학습 자료|AI양재허브 교육으로 Elice에 올라온 선행학습 강의와 퀴즈를 통해 1주차 DOM 개념, JS로 DOM 조작 등의 개념을 학습하고 실습을 수행했다. 아직까진 뚜잇 프로젝트 등으로 이미 충분히 학습 및 활용해봤던 영역이지만, 지난 기간동안 Object 개념과 자료구조를 학습하여 그 당시 활용했을때와 근본적 이해의 큰 차이를 느끼고 있음|
|22.07.01|현대 MOBIS 알고리즘 경진대회 예선 참가|개발: 알고리즘|[내 Mobis 예선 풀이](https://github.com/ABizCho/py_algorithm/blob/main/SolvedOthers/mobis_solved_p1.py)|현대 Mobis 알고리즘 경진대회 예선에 참가해봤다. 아직 참가에 의의를 두는 정도이지만, 머지않아 꼭 입상하리라 다짐한다.|
|-|BeautifulSoup vs Scrapy 비교|개발: 웹스크래핑|[Scrapy vs BeautifulSoup](https://livedata.tistory.com/25) / [Scrapy Vs Selenium Vs Beautiful Soup for Web Scraping.](https://medium.com/analytics-vidhya/scrapy-vs-selenium-vs-beautiful-soup-for-web-scraping-24008b6c87b8)|SMA 프로젝트에 사용될 WEB scrapper를 비교해 보았다. SMA프로젝트는 1회성 연구로, 비교적 확장성은 부족하지만 사용이 편리한 BeautifulSoup를 이용해 먼저 접근해보고자 한다.|
|-|백준 단계9.재귀 & 단계11.정렬 ~ ing|개발: 알고리즘|[MyAL: 재귀 풀이레포](https://github.com/ABizCho/py_algorithm/tree/main/Solved_BJ/P8_RECURSIVE) / [MyAL: 2750 풀이](https://github.com/ABizCho/py_algorithm/blob/main/Solved_BJ/P11_SORT/solved_2750_sortNum1.py)| 백준 단계별 풀이로 9단계 재귀 몇가지 풀이 + 단계별 11단계 2750문제를 O(N^2)의 간단한 정렬 3가지 (선택/삽입/버블)을 이용해 풀이했다.|

<br><br>

## 6월
|날짜|배운것|분야|관련자료|한줄평|
|------|---|---|---|---|
|22.06.28|SMA 학부 연구 프로젝트 시작|데이터분석: 실전|[SMA_2022summerProject](https://github.com/ABizCho/SMA_2022summerProject)|2022 SUMMER 학부 연구 프로젝트로 응모한 주제가 선정되어 프로젝트에 참여하게 됐다. 잠이 잘 오지 않아, 조금 일찍 프로젝트 Process와 연구 디테일등을 정의한 보고서를 작성했고, 레포를 생성하여 기반작업에 착수함.|
|22.06.27|JS fetch 메서드로 json file 접근|개발: JS|[Fetch 사용하기,MDN](https://developer.mozilla.org/ko/docs/Web/API/Fetch_API/Using_Fetch)|AI 양재허브 SW 양성교육 과정의 코딩테스트로 fetch를 이용한 json 접근을 다뤘다. 사실상 첫 fetch 활용이었기에 테스트 종료 후 해당 REF를 통해 추가적으로 공부했다.|
|22.06.26|객체지향의 사실과 오해#1 ~38p|개발: OOP|[스터디 노트: 객체지향의 사실과 오해](https://github.com/horizontal-library/The-Essence-of-Object-Orientation)|1장에선 객체지향의 기본 구성과 개념을 바로잡을 수 있었다. 객체지향 설계에선 시스템의 기능이라는 공동의 목표를 위해 여러 객체들이 각자의 역할(&책임=메서드)을 가지고 공동체를 이루고 각자의 책임 밖의 일을 위해 '메시지(요청/응답)'를 주고 받으며 '협력'한다. '객체:역할'은 'N:N'의 관계를 가질 수 있다. 이는 대체가능성을 암시하며, 객체가 메시지에 응답하기 위해 자신의 메서드를 자율적으로 선택한다는 점에서 '다형성'과 깊게 연결된다. 적절한 메서드 할당으로 자율적인 객체를 설계함으로써 불필요한 의존성을 제거할 수 있고, 이는 '캡슐화'와 깊은 관련이 있다. / 이처럼 시스템은 자유로운 객체들의 공동체라는 개념 하에 객체단위로 분할될 수 있으며, 시스템 기능은 협력의 연쇄로 수행될 수 있다는 것이 객체지향 설계의 본질이다.|
|-|'이취코테' #계획수립|개발: 알고리즘|[스터디 노트: 이것이 취업을 위한 코딩 테스트다](https://github.com/horizontal-library/This-is-The-Coding-Test)|직전학기 수강한 자료구조 강의를 기반 지식으로, 추가적인 코딩 테스트 준비와 알고리즘 학습을 위해 해당 책을 구매함. 하계 방학기간 중 백준 단계별 풀어보기와 함께 집중적으로 학습할 예정이다.|
|-|'이취코테'#정렬-1|개발: 알고리즘|[스터디 노트: 이것이 취업을 위한 코딩 테스트다](https://github.com/horizontal-library/This-is-The-Coding-Test)|정렬 문제는 보통은 타 알고리즘 내의 기반작업(전처리)로 사용되며 대표적인 예시가 정렬을 기반으로 하는 '이진탐색'임. 정렬문제의 case는 총 세가지로, (1)정렬 라이브러리 함수 sorted() - O(nlogn)로 풀수 있는 문제. (2) 정렬 원리를 묻는 문제(ex.병합정렬 등) (3)큰 효율을 요구하는 문제(ex.카운팅 정렬) 등이 있다. / 세 케이스 각자는 문제에 주어진 조건에 따라 유동적으로 선택해야 하며, 카운팅(계수)정렬이 보통 케이스3의 대표적 기법이며 해당 알고리즘을 적용하기 위해서는 데이터 크기가 제한된 문제여야 함. 가장 일반적인 경우엔 sorted()의 O(nlogn)으로 해결 가능함.|
|-|이것이 취업을 위한 코딩 테스트다 #|개발: 알고리즘|[스터디 노트: 이것이 취업을 위한 코딩 테스트다](https://github.com/horizontal-library/This-is-The-Coding-Test)|직전학기 수강한 자료구조 강의를 기반 지식으로, 추가적인 코딩 테스트 준비와 알고리즘 학습을 위해 해당 책을 구매함. 하계 방학기간 중 백준 단계별 풀어보기와 함께 집중적으로 학습할 예정이다.|
|22.06.24|AI양재허브 웹트랙 자소서 작성, SNS분석 학부연구 기획서 작성||[(2) SMA_2022summerProject](https://github.com/ABizCho/SMA_2022summerProject)|-| 
|22.06.21|타과목 기말고사 마감~22|-|-|-|
|22.06.17|고급 정렬까지 자료구조 기말공부~ing|개발: 자료구조|-|-|
|22.06.15|탐색부터 이진탐색트리까지 기말공부~ing|개발: 자료구조|-|-|
|22.06.11|robots.txt, 로봇 배제 표준|개발: 크롤링|[robots.txt 올바르게 사용하기](https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=http-log&logNo=221104827805)/[웹 크롤러좀 그만 만들어라](https://velog.io/@mowinckel/%EC%9B%B9-%ED%81%AC%EB%A1%A4%EB%A7%81-I)|크롤링으로 인한 잡코리아와 사람인, 여기어때와 야놀자 간 법정공방과 처벌사례가 있음을 익히 들어 알고있었는데 이로 인해 크롤링 행위 자체를 꺼려하게 되었다. 학부연구 주제가 SNS분석인데 크롤링을 합법적으로 사용하기 위해 어떤것을 고려해야하 하는지 조사하다가 로봇배제표준 이라는 규약을 알게되었고, 이를 위한 개별 사이트의 robots.txt라는 문서가 존재함을 알게 되었음.|
|22.06.10|고급정렬-셸힙정렬|개발: 자료구조|2022 1st Ajou 자료구조|수업에서 마지막장 고급정렬 중 몇가지를 배웠다. **(1)셸 정렬**은 삽입정렬이 정렬된 배열에 대해 대단히 좋은 성능을 보이지만 이웃 위치로만 이동하기 때문에 정렬을 위한 비교-이동 연산이 많은 단점을 보완한 아이디어로, 이동 제한을 GAP을 이용한 부분리스트 활용을 통해 해결하여 평균 O(n^1.5)의 시간복잡도를 만드는 정렬 알고리즘이다. **(2)힙 정렬**은 힙의 최대값 혹은 최소값의 접근이 매우 효율적이라는 점에 착안한 아이디어로 힙 정렬이 유용한 경우는 전체 데이터가 아닌 특정 수의 최대값 혹은 최소값 몇개에 대한 정렬만 필요한 경우 효율적이고 유용하다. 시간복잡도는 모든 경우에 동일하게 O(nlogn)을 보장한다.|
|22.06.08|파이썬 NLP와 감성분석, Word Cloud|py데이터분석: 실전|[Yelp NLP & Sentiment analysis ,kaggle - SACHIN SHARMA](https://www.kaggle.com/code/sachinsharma1123/sentiment-analysis)|ML PY NLP관련 과제를 진행하던 중 워드클라우드를 추가적으로 만들고 싶어서 여러 자료를 찾아보고 적용했다.|
|-|파이썬 NLP Word Tokenization|py데이터분석: 실전|[NLP Tokenization 토큰화, wikidocs](https://wikidocs.net/21698)|토큰화 방법과 라이브러리를 여러가지 찾아보았다. 토큰화 방법의 주요한 차이는 문장의 분리 기준에 달려있다. 구두점 혹은 특수문자 그것이 아니라면 띄어쓰기 기준으로 문장을 단어로 토큰화 할 것인가 등 인데, 영어는 특히 단어와 구두점의 연결성이 깊다보니 단순 구두점 기준은 여러 문제를 낳을 수 있다. 한국어의 경우 교착어의 특성 등 영어에 비해 토큰화에 특히 어려움이 있다. 이는 이전 R관련 강의들에서도 많이 공부했기에 예전 강의자료를 참고하자. 한국어 '품사태깅' 방법도 간단하게 수록되어있으니 해당 자료 참고.| 
|-|파이썬 NLP 빈도수 분석|py데이터분석: 실전|[자연어처리(NLP): 데이터의 분리/정수인코딩, 딥러닝을 이용한 자연어처리 입문](https://wikidocs.net/book/2155)|토큰화된 단어의 리스트로부터 빈도수를 카운트하기 위해 nltk에선 FreqDist라는 자체 클래스를 제공한다. 케라스 등 다른 생태계마다 빈도수 측정 및 특징과 한계점이 다르므로 주어진 상황을 종합적으로 고려해서 선택한다.|
|-|최단경로 알고리즘: 다익스트라, 플로이드|개발: 자료구조|2022 1st Ajou 자료구조|저번 시간에 이어 최단경로 알고리즘의 자세한 구현 및 시간복잡도 비교를 배웠음. \ **(1)다익스트라**는 한 정점으로부터 다른 모든 정점까지의 최단경로를 구하며 한번의 step에 하나의 경로를 탐색하며 이를 n개의 노드에 대해 실시하므로 전체 시간복잡도는 O(n^2). 단계마다 방문하지 않은 노드 중 최단거리가 가장 짧은 노드를 선ㄴ택하기 위해 힙 자료구조를 이용할 경우 O(ElogN)이 걸림. \ **(2)플로이드**는 모든 정점 사이의, 즉, 모든 정점 쌍의 최단경로 거리를 구한다. 각 단계마다 O(n^2)의 연산으로 현재 스텝의 노드를 거치는 모든 경로를 고려하며, 이를 모든 정점 n에 대해 실시할 경우, 총 시간복잡도는 O(n^2 x n)이므로 총 O(n^3)만큼의 시간복잡도. 대부분의 실전상황에서 플로이드는 낮은 효율성으로 적용하지 않으며 직관적 구현의 장점으로 최단경로 원리학습에 주로 사용된다.|
|22.06.06|자료구조 탐색, 이진트리 복습|자료구조: 복습|[내노트: 작성요망]()|기말대비 탐색과 이진트리를 복습했다.|
|22.06.05|파이썬 회귀의 다중공선성 해결|데이터분석: 실전|[파이썬 스케일링 실전](https://datascienceschool.net/03%20machine%20learning/04.03%20%EC%8A%A4%EC%BC%80%EC%9D%BC%EB%A7%81.html) / [[Python] 데이터 사이언스 스쿨 - 5.3 다중공선성과 변수선택](https://romg2.github.io/dss/04_%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%82%AC%EC%9D%B4%EC%96%B8%EC%8A%A4-%EC%8A%A4%EC%BF%A8-5.3-%EB%8B%A4%EC%A4%91%EA%B3%B5%EC%84%A0%EC%84%B1%EA%B3%BC-%EB%B3%80%EC%88%98%EC%84%A0%ED%83%9D/)/ [다중공선성(Multicollinearity)과 VIF(Variance Inflation Factors)](https://bkshin.tistory.com/entry/DATA-20-%EB%8B%A4%EC%A4%91%EA%B3%B5%EC%84%A0%EC%84%B1%EA%B3%BC-VIF) / [Python 다중공선성 해결, YSY^](https://ysyblog.tistory.com/122)|해당 참고자료에 (1)정규화, (2)변수선택법 (3)PCA 를 이용한 해결법 수록|
|-|다중공선성 해결법:파이썬 Scaler 종류,특징|데이터분석: 이론|[[Python/sklearn] Scaler 별 특징 / 사용법 / 차이 / 예시](https://mingtory.tistory.com/m/140)|Standard scaler, Normalizer, MinMaxScaler, Robust Sclaer 등 정규화를 위한 python 스케일러들의 특징과 사용례 등을 정리한 노트|
|-|파이썬 오차의 정규성 등 오차 고려사항 진단 방법들|PY데이터분석: 실전|[모형의 진단과 수정,데싸스쿨](https://romg2.github.io/dss/01_%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%82%AC%EC%9D%B4%EC%96%B8%EC%8A%A4-%EC%8A%A4%EC%BF%A8-4.9-%EB%AA%A8%ED%98%95%EC%9D%98-%EC%A7%84%EB%8B%A8%EA%B3%BC-%EC%88%98%EC%A0%95/)|-|
|-|파이썬 종속변수의 로그변환 - 잔차의 정규화|PY데이터분석: 실전|[파이썬 회귀- 종속변수 로그 변환,머신러닝 완벽가이드](https://romg2.github.io/mlguide/10_%EB%A8%B8%EC%8B%A0%EB%9F%AC%EB%8B%9D-%EC%99%84%EB%B2%BD%EA%B0%80%EC%9D%B4%EB%93%9C-05.-%ED%9A%8C%EA%B7%80-%EC%8B%A4%EC%8A%B5/)|ML팀플 adr 다중선형분석 중 잔차의 정규성 위반을 문의했는데, 팀원 유선님이 종속변수 로그화를 통해 해결할 수 있는 가능성이 있다고 관련자료를 보내주셨다. R기반 자료라 파이썬 방법을 탐색했고 몇가지 노트를 발견하여 적용해보고자 한다.|
|22.06.04|DA 다중회귀분석의 고려, 검토사항|데이터분석: 이론|[다중회귀분석 시 검토사항, specialscene](https://specialscene.tistory.com/94)|**1) 모형의 통계적 유의성**: F-통계량 : 유의수준 5%하에서 F-통계량의 P-값이 0.05보다 작으면 추정된 회귀식은 통계적으로 유의함 : F통계량이 크면 P-val이 0.05보다 작아짐->대립가설 채택 / **2) 회귀계수의 유의성** : t-통계량 : t-통계량으로 회귀계수의 유의성이 검증된 계수들을 가지고 이를 조합하여 모형을 구성 : 통계적 유의성은 회귀계수에 대한 t-통계량 and 회귀식에 대한 F-통계량을 통해서 판단 / **3) 모형의 설명력** : 결정계수(R^2) or 수정된 결정계수(Adjusted R^2) 확인, 0~1 사이 값이며 1에 가까울수록 설명력 높음 : 결정계수가 낮으면 회귀식의 설명력이 낮은 것,결정계수가 낮다고 통계적으로 유의미하지 않은 것은 아님 / **4) 모형의 적합성** : 잔차와 종속변수 산점도로 확인 / **5) 데이터가 회귀분석의 가정을 만족시키는가?** : 선형성, 독립성, 등분산성, 비상관성, 정상성 / **6) 다중공선성** : **6-1)** 분산팽창요인(VIF) 4보다 크면 다중공선성이 존재한다고 판단, 10보다 크면 심각한 문제가 있는 것으로 해석 :: **6-2)** 상태지수: 10이상이면 문제, 30보다 크면 심각한 문제 -> **6-해결방안** - 다중공선성의 문제가 발생하면 문제가 있는*(1) 변수를 제거 /(2)주성분회귀 적용/ (3)능형회귀 모형 적용* 을 통해 해결 +보통 결정계수값이 매우 높으나 각 독립변수들의 계수가 유의하지 않은 경우 다중공선성을 의심해 볼 수 있음|
|-|DA Python의 다중회귀분석 고려사항 검정법|py데이터분석: 실전|[파이썬 단순 및 다중선형회귀의 유의성 등 검정법](https://ordo.tistory.com/103)| 
|22.06.03|자료구조 DS PJ 관련 피드백|자료구조: 프로젝트|2022 1st Ajou 자료구조, 우현제|자료구조 프로젝트 1차 리포트 제출분에 관련하여 교수님께 피드백을 부탁드림. 주식 트레이딩 시스템을 구현하기 위해 BST와 연결리스트기반 큐 를 사용했는데, 이는 BST를 사용할 때 가격을 탐색키로 줬을 때 발생할 중복 문제를 피하고자 의도했던 부분이었음. 노드 하나의 키를 가격으로 사용하고 담길 DATA를 QUEUE로 구성한 것인데, 기존의 데이터에는 주문자,수량을 삽입하였으나 이경우 중복되는 가격의 특정 주문을 취소하고자 할때 ID가 없어 주문을 특정할 수 없기에 특정 주문값에 ID를 삽입할 것을 권고하셨음. 다만 특정 BST탐색으로 중복가격노드에 도달했을 때, ID기반 큐 탐색으로 방법을 전환하기 위해 어떤 방법을 사용해야 효율적일 지 고민됨.|
|-|가중치 그래프, MST 알고리즘|자료구조: 가중치그래프: MST|2022 1st Ajou 자료구조, 우현제|가중치 그래프의 MST(최소신장트리)를 구하는 알고리즘 배움. 먼저 MST 알고리즘은 크루스칼,프림 이 있으며 둘 다 그리디이지만 접근법이 다름. /**[1.1 MST-K]** 크루스칼은 오름차순 정렬을 전제로 하며 현재정점의 인접정점 중 최소 가중치를 선택해나가는 방법이며 union-find로 사이클존재여부를 검사하여 배제하는 방법이며.크루스칼 구현을 위해 파이썬에선 인접행렬의 요소값으로 edge 정보를 (vertex1,vertex2,가중치) 모습의 튜플로 저장함 / **[1 MST 비교]** Kruskal의 시간복잡도는 정렬하는 시간에 가장 많이 소요하며 그에 성능이 좌우됨 : O(e log e) : Sparse 그래프(엣지가 적은)에 적용하는 것이 적절 <-> Prim은 한스텝의 O(n)을 약 n번 반복하므로 O(n^2)의 시간복잡도이며 dense그래프(엣지많은)에 적용이 적절. 둘의 적용을 고려할 때 가지고 있는 정보가 인접정점이냐 모든 정점정보냐에 따라 선택함. |
|-|가중치 그래프, 최단경로 알고리즘|자료구조: 가중치그래프: 최단경로|2022 1st Ajou 자료구조, 우현제 / [다익스트라, 나동빈](https://m.blog.naver.com/ndb796/221234424646)|가중치 그래프의 최단경로를 구하는 Dijkstra, Floyd 알고리즘 배움. / 다익스트라는 다이나믹 프로그래밍을 활용한 방법이며 GPS SW등에 많이 사용. 하나의 Vertex로부터 다른 모든 Vertex로 가는 최단경로를 알려줌. 음의 간선은 포함X. 최단거리는 여러개의 최단거리로 이어져있다는 아이디어에서 하나의 최단거리를 구할 때, 그 이전까지 구했던 최단거리 정보를 그대로 사용하는 방법 사용하며 이것이 다이나믹 프로그래밍 개념과 부합. / 플로이드는 한 정점으로부터의 다른 정점으로 향하는 모든 최단경로였던 다익스트라와 달리, 모든 vertex 사이의 최단경로를 찾는 개념. 2차원 배열 A를 이용해 3중반복을 하는 루프를 구성하며, 배열 A의 초기 값은 인접행렬의 가중치로 설정하는 방법 선택. 자세한 내용은 추가 공부 필요| 
|-|ML특강- crypto tempo 대표: 블록체인 이론|IT트렌드: 블록체인&디파이|2022 1st Ajou DA-ML 외부초청특강/ [Ripple의 블록체인 생성 시각화 사이트](livenet.xrpl.org)|ML 특강으로 초청된 박미쁨 대표님의 강의를 들었음. 블록체인의 탄생 배경(계약의 역사)과 기본 개념, 그리고 그 응용인 디파이에 대한 내용. 블록체인은 기본적으로 '기록','위변조 방지','사본(증인)'이라는 세가지 계약의 조건을 충족시키는 기술이라고. 블록체인에 대해 어렴풋이 탈 중앙화 라고만 알고 있었고 복사본간의 비교라는 개념만 알고있어서 해시와 비슷한 개념이겠구나 라고 생각했었는데, 실제로 해시함수를 사용한 32byte 블록 생성-> 수많은 사본 생성 -> 사본 간의 해시값 비교를 통한 위변조 감지 원리라고 함. 그래서 최근에 해시를 배웠기에 32byte 해시값이라면 분명 충돌이 발생할 수 있다고 생각하였고, 이 경우 원본문서를 어떻게 식별할 것인지 궁금하여 질문을 드렸는데 원본문서는 원본문서대로 함께 비교기준으로 사용되며 원본문서와 해시값 등의 모든 조건이 동일하여 식별에 문제가 생길 가능성은 실제 계산 상 태양과 행성의 충돌 가능성 수준이기에 사실상의 가능성이 없으나 결국 그 가능성이 존재하므로 기술적으로 완전무결한 것은 아니라 답해주셨음.|
|-|ML특강- Smart Contract & Defi|IT트렌드: 블록체인&디파이|2022 1st Ajou DA-ML 외부초청특강|[블록체인: Non-cutodial, Permissionless] ->[교집합: Transparency, Interoperability] <- [Smart Contract: Programmability] / 블록체인이 중간 매개자 역할을 하여, 송금계약 상 전통적 중간매개 보증주체가 필요 없어짐. 내 돈은 내가 가지고 있다가 블록체인 기술에 의해 직접 보내지는 것이며 이것이 그리 많이 들었던 '블록체인의 탈 중앙화' 개념의 핵심인 것, 다만 기성의 중앙시스템이 아닌 코인 거래소에 중앙화되어 내돈이 내돈이 아닌 아이러니한 상황이 생기며 거래소의 신뢰도와 보안신뢰도가 중요해짐. / Defi는 Money Legos라고 표현할 수 있음. 스마트 컨트랙을 잘 기획-구현해낸다면 은행, 채권, 거래소 역할을 할 수 있을 것 이라는 가능성으로 여러가지 블록체인 서비스가 개발되었으며 'Interoperability'속성 덕분에 하나하나의 서비스가 상호연동하며 커다란 금융시장을 형성했고 이것이 Defi 개념임. *EX) 스태블코인(USDT:1달러에 페어를 이루도록 설계된 특수..등), DEX(Uniswap등),Lending platform(AAVE등),Asset management(Yearn Finanace등),Derivatives(dYdX등),Insurance(Nexus Mutual 등)*, 특히 중요한 것은 stable코인 서비스인데, 이로 인해 달러가치 등 실물화폐와 연동하여 다른 서비스들에 사용될 화폐시스템 안정기반을 마련했기 때문. 현재로서는 그 생태계가 많이 확장-발전하여 단순 거래 뿐 아니라 복잡한 금융생태 - 예를들어 대출, 파생상품 거래등이 정착하고있음. / DEFI생태에 의한 새로운 탈중앙화 수평 조직구조인 DAO(Decentralized Autonomous Organizations도 주목해 볼 만.|
|-|실시간 데이터분석 방법, 스트리밍 분석|데이터분석: 실시간 분석|[실시간 빅데이터 분석, 네이버D2]/ [스트리밍 분석: 현대적 데이터 결정 솔루션, Google]/[실시간 분석,TIBCO](https://www.tibco.com/ko/reference-center/what-is-real-time-analytics)|항상 서비스지향적으로 데이터 분석을 꿈꿔왔는데 서비스를 위한 실시간 분석기술을 아직 배우지 못해서 지금부터 혼자서라도 학습하고 적용해보고자 함. 현대 데이터 수집의 스트리밍 분석이란 '이벤트 스트리밍-움직이는 데이터 흐름'을 말함. 이 스트림은 동작 결과로 발생하는 모든 이벤트로 구성&모든 시간대 포함함. 스트리밍 분석 이용 시 이벤트 스트림 생성 즉시 자동 분석동작 수행 가능. 실시간 분석을 위해선 이런 스트리밍 처리 혹은 실시간 분산 쿼리 기법 등을 사용하는데 이는 실시간 처리가 어려운 하둡의 배치방식 맵리듀스의 한계 등을 극복하는 기법들. 아파치 스파크 등 그 밖의 다양한 방법들이 네이버D2에 잘 기재돼있으니 필요시 글을 다시 참고. 해당 글의 마지막 멘트의 예상처럼 빅데이터 처리를 위한 분산기술 종합 플랫폼 제공 기업들이 현재 매우 활성화됨 AWS,아파치,네이버,카카오 등에서 제공하는 솔루션들도 공부해볼 필요|

<br><br>

## 5월
|날짜|배운것|분야|관련자료|한줄평|
|------|---|---|---|---|
|22.05.30|연관분석 - 유통업계의 Segmenting CTA|머신러닝: 이론|[연관성 분석 이해하기 & CTA, 뷰저블](https://www.beusable.net/blog/?p=2481)|pyML 그룹 프로젝트의 연관분석의 결과를 받아보고 이를 어떻게 해석할 것인지 방법을 고민하며 여러 자료를 탐색하던 중, Segmenting CTA에 대해 발견했다. 평소에 궁금증이 크게 있었는데 관련된 용어를 모르다보니 자세히 찾아보지 못했는데 해당 글에서 장바구니 페이지의 실사용예를 기준으로 설명해주어 흥미롭게 보았다. 시간이 나면 추가적으로 알아봐야겠다.|
|22.05.28|객체지향의 사실과 오해#1 ~28p|개발: OOP|[객체지향의 사실과 오해, 조영호](https://github.com/horizontal-library/The-Essence-of-Object-Orientation)|객체지향을 제대로 배워봐야겠다는 생각으로 조영호 저자의 오브젝트를 읽고자 했으나 해당 책을 읽기위한 배경지식이 부족하지 않나라는 생각이 들어 여러가지 선행도서를 찾아보았다. 감사하게도 조영호 저자가 이미 나같은 중생을 위한 책을 출간하셔서 바로 구매했고 horizontal-library에 등록하여 첫 학습을 진행했다.|
|22.05.27|가중치 그래프와 크루스칼 알고리즘|개발: 자료구조|2022 1st Ajou 자료구조|신장트리S 로부터 최소신장트리(MST)를 찾는 것은 최소비용의 경로를 구할 때 사용됨. DAG:비사이클방향그래프 를 대상으로 적용. 이를 위한 MST알고리즘은 프림 & 크루스칼 알고리즘이 존재하며 둘 다 그리디 알고리즘. 크루스칼 알고리즘의 경우 UNION-FIND함수를 응용하여 사이클 형성여부를 판별. 크루스칼 순서: 1) Edges를 가중치를 기준으로 오름차순 정렬 2) 가중치가 작은 edge부터 선택하여 사이클 형성여부 판별 3) 비사이클 시 UNION수행 (2-3반복)|
|-|Association Rules(연관규칙)의 measures 해석과 적용|머신러닝: 이론|[연관분석 해석,LIB](https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=gkenq&logNo=10188110816)/[PyDA:연관분석 음식메뉴 분석 및 결과해석, 망망낭낭](https://tjansry354.tistory.com/10)/[추천을 위한 연관규칙의 measures 해석, ](https://needjarvis.tistory.com/59)|연관분석은 UnsupervisedML의 대표적 기법 중 하나로 추천시스템에 주로 활용. 연관규칙을 생성하여 분석함. MEASURES로 support,confidence,lift가 나오는데 이들을 적절히 고려하여 유의미한 규칙 발견 가능함. 이에 대한 자세한 해석은 노트 참고.|
|22.05.26|AI포비아에 관한 토론|머신러닝: AI트렌드|2022 1st Ajou 인공지능의 이해|AI의 등장으로 인한 일자리 대체등의 두려움이 인공지능 포비아를 낳고 있음. 오늘 인공지능 포비아와 파생되는 주제들에 대해 강의 토론팀 내에서 토론을 진행해보았다. 토론을 준비하며 개발분야의 AI위협 근황을 조사해봤는데, 바로 엊그제 22년5월24일자로 MS가 Github Copilot의 일반출시가 임박했음을 발표했다고 한다. 2시간짜리 코드를 2분만에라고 기사제목은 다소 과장을 섞어놓았으나, 경향과 발전속도의 지수증가성을 생각해 보았을 때 일반 컴포넌트 수준의 기능구현을 AI가 완전히 대체하는 일 정도는 그리 멀지 않은 미래에 찾아올 것임이 느껴진다. 당장은 효율과 구조보다 기능에 집중된 퍼포먼스이지만 로우코드,노코드가 일반화된다면 개발자가 경쟁력을 가지고 배양해야할 소양은 무엇일까, 보다 기초적이고 핵심적인 가치들을 추구해야 한다고 생각한다. 전산학과 컴퓨터에 대한 이해, 자료구조와 알고리즘, 디자인 패턴등 더욱 잘 이해하고, 체계적인 구조화 능력을 가진 아키텍터의 소양에 더불어 비즈니스 관점에서 유의미하고 창의적인 아이디어를 제안할 수 있는 비즈니스 인사이트 또한 더욱 주목받게 될 것이라고 생각한다. 그리고 권위자들의 주장에 따른 특이점의 시기는 그리 멀지 않았는데 정치권에서 AI의 생산성 향상과 일자리 상실로 인한 소득분배 정책에 대해 더 적극적으로 논의하지 않는 점이 의아하다고 생각한다. 하루빨리 이에 대한 논의가 시작되어 AI와 동반자가 될 수 있도록 사회적 공감대와 제도적 장치를 마련해야 할 것이다.| 
|22.05.25|그래프 자료구조 - DFS, BFS, 신장 트리(ST), 최소 신장 트리(MST), 위상정렬(TS)|개발: 자료구조|2022 1st Ajou 자료구조/[신장트리와 최소비용 신장트리, 킹포도](https://kingpodo.tistory.com/49)/[위상 정렬, 동빈나](https://m.blog.naver.com/ndb796/221236874984)|그래프 자료구조를 이용한 탐색인 DFS,BFS 그리고 ST,MST,위상정렬을 배움. 1) 그래프를 이용할 때 DFS,BFS의 선택에 따른 성능차이는 거의 존재하지 않고 그래프 구현에 있어 인접행렬/인접리스트 중 상황에 따라 어느것을 선택하느냐에 따라 성능차이가 주요하게 발생함. 2) 신장트리는 BFS/DFS를 활용해 만들 수  있는 연결그래프의 부분 집합 그래포이며 그래프에 사이클이 존재하면 안됨. 3) MST는 무방향 가중치 그래프에 대해 VERTEX들의 가중치 합이 최소가 되는 신장 트리임. 프림,크루스칼(둘다 그리디) 알고리즘으로 구현 가능 4) 위상정렬은 순서가 정해진 작업을 차례로 수행할 때 순서를 결정해주기 위해 사용하는 알고리즘. 위상정렬은 여러개의 답이 존재할 수. DAG(Directed Acyclic Graph:사이클이 없는 방향 그래프)에만 적용 가능-> 사이클이 있으면 위상정렬 수행 불가. 스택과 큐를 이용한 구현 가능. O(V+E)의 시간복잡도|
|-|Python 텍스트 마이닝 이론|머신러닝: 이론|2022 1st Ajou DA-ML/[내 깃허브 정리: py_machineLearning](https://github.com/ABizCho/py_machineLearning/tree/main/ML_PRAC)|텍스트 마이닝은 Unstructured & semi-structured하게 구성된 Textual Data에 대해 Data Mining, information retrieval, NLP등의 방법론을 사용하여 텍스트 데이터를 분석하는 기법이다. 데이터 표현은 복잡한 편이며, 수만 이상의 공간복잡도를 가질 수 있으며 관련 시장은 매우 크다. 법해석, 연구, 재무보고, 약학, 생물학, 마케팅 등의 도메인에 큰 실효성을 가짐. 스팸필터, 메일분류, 자동응답 등의 상세분야에 대표적으로 사용. 정보추출, 문서검색, sentiment mining/opinion mining and classification 상세과업이 존재 / Tokenization, stemming, stop-words,N-grams의 전처리 & vector-space model,Bag of words, weighting with TF-IDF등의 모델링, Cosine similarity의 유사도 측정 이 텍스트마이닝을 위한 중요 개념이다.|
|22.05.23|인공지능 딥 러닝 이론|머신러닝: 이론|2022 1st Ajou 인공지능 이해/[Google Neural Network Playground](http://playground.tensorflow.org)|인공신경망 개념에서 다양한 활성화 함수를 적용시켜 기울기 소실 문제를 해결하고 과적합문제를 해결하기 위한 드롭아웃 학습방법을 도입한 ML방법으로 CNN,RNN등이 존재, Google Neural Newtwork Playground라는 인공신경망 동작 서비스로 딥러닝 실습해봄. 딥러닝의 활성화 함수 적용은 선형 데이터에 선형함수를 적용함으로써 망이 깊어질 수 없는, 즉, hidden layer(은닉층)이 1 이상으로 증가할 수 없는 문제로 뉴런에 해당하는 노드가 아무리 늘어나도 성능이 나아지지 않는 문제를 해결해줌.|
|-|딥러닝 활성화 함수|머신러닝: 이론|[[Deep learning] Activation Function(활성화 함수) 개념](https://han-py.tistory.com/211)/[활성화 함수(activation function)을 사용하는 이유](https://ganghee-lee.tistory.com/30)/[활성화 함수](https://velog.io/@hyunsuki/Activation-Function%ED%99%9C%EC%84%B1%ED%99%94-%ED%95%A8%EC%88%98)|딥러닝에서 활성화 함수를 사용하는 이유와 그 기능에 대해 더 정확히 알아보기 위해 찾아보았다. 보통의 ML 선형 문제에 대해서는 선형함수를 사용하는 학습모델을 적용하는데 이는 선형모델의 특성 상 뉴런(노드)의 수를 아무리 늘려도 은닉층은 하나밖에 만들 수 없기 때문에 XOR, Circle 등의 비선형 문제에 효과적인 접근이 불가능 하다. 딥 러닝에서는 대표적으로 RELU,탄젠트,시그모이드 등의 활성화 함수를 적용하여 비선형으로 문제를 풀어낼 수 있게 해주며 이에 따라, 은닉층의 깊이를 깊게 만들어 문제를 효과적으로 처리할 수 있다. Spiral(나선) 데이터는 비선형 중에서도 특히 까다로운 문제인데, 활성화 함수를 사용하고 은닉층 수와 노드 수를 적절히 늘림으로써 해결할 수 있다.|
|22.05.22|개발에서의 두뇌 시뮬레이션 능력|개발: 마인드셋|[일잘알과 시뮬레이션, 포프](https://youtu.be/0oMv9xR2f8o)|비즈니스관점의 문제해결을 위한 공감능력의 중요성을 여러곳에서 들어본 적이 있다. 개발자에게 있어서도 시뮬레이션 능력은 발전을 판가름하는 매우 중요한 요소라고 한다. 기능에 대한 시뮬레이션, 논리적 디버깅 시뮬레이션, 비즈니스적 시뮬레이션 사고 등. 두뇌로 사고하도록 노력하자.
|22.05.20|그래프 자료구조 학습|개발: 자료구조|2022 1st Ajou DS Lect|그래프는 Vertex와 Edge로 구성된 자료구조이다. 오일러 문제, 오일러 정리로부터 그래프 이론이 탄생했고 이로부터 유래했다. 선형자료구조, 트리를 포함하는 개념의 자료구조이며 그 세부 특성에 따라 네트워크 등으로 파생되기도 한다. 복잡한 관계의 표현에 적합하다. 인접행렬과 인접리스트로 표현 가능하며, Vertex 수와 Edge 수의 상대적 비에 따라 장단점이 극명하기에 상황에 따라 적절히 구현 한다.|
|-|AVL트리 재균형 회전 원리|개발: 자료구조|[AVL트리 개념, 코드라떼](https://www.youtube.com/watch?v=9BiHgy40NNE)/[기술사-알고리즘-AVL, 그리타](https://www.youtube.com/watch?v=mKxUQgx0a_Q&t=206s)|AVL트리의 재균형은 균형의 좌우 편향에 따라 결정되며, 양수일 경우 좌편향 음수일 경우 우편향으로 판단하고 그 파생에 따라 LL,LR,RR,RL의 네가지 타입의 리밸런싱 경우가 존재한다. LL타입의 회전은 시계방향, RR타입의 회전은 반시계방향으로 수행한다.|
|-|이진탐색, BST, AVL 복습 및 정리|개발: 자료구조|[내 노트: [DS] 탐색트리 : 이진탐색 to 이진탐색트리(BST) to 균형이진탐색트리(AVL)](https://velog.io/@he1256/%EC%9E%91%EC%84%B1%EC%9A%94%EB%A7%9D-DS-%ED%83%90%EC%83%89%ED%8A%B8%EB%A6%AC-%EC%9D%B4%EC%A7%84%ED%83%90%EC%83%89%ED%8A%B8%EB%A6%AC-AVL%ED%8A%B8%EB%A6%AC)|이진탐색과 이진탐색트리의 장단점 그리고 균형이진탐색트리와 그 원리를 복습하여 정리했다|
|22.05.19|검증하는 프로그래머|개발: 마인드셋|[프로그래머는 검증한다, 포프](https://youtu.be/hWwJF-fU2Lg)|참조 기계가 되지 말고 근본적인 문제해결 능력을 배양하자.|
|-|OOP와 부주의한 개발자|개발: OOP|[OOP는 허접한 개발자 때문에 발전했다?, 포프](https://youtu.be/oHaGgLRZy3Y)|부주의한 개발자로 인한 더티코드를 방지하기 위해 문맥마다 클래스를 만드는 등 OOP는 예방적 관점에서 사용된다. 시스템적으로 문제를 예방하는 사고가 필요하다.|
|22.05.18|디자인패턴 S 단일책임원칙|개발: 디자인패턴|[단일책임원칙](https://youtu.be/Tit-bJJm9iw)/[OOP 단일책임, 알파카](http://naver.me/xsUb2j5I)|객체지향 설계를 위한 SOLID 원칙 중 S에 해당하는 단일책임 원칙. 하나의 객체는 하나만의 동작을 갖는다. 객체의 책임범위를 줄임으로써 수정으로 인한 cascading 부작용을 줄이며 무분별한 접근을 방지한다.|
|-|디자인패턴 O 개방폐쇄원칙|개발: 디자인패턴|[Open-Closed](https://youtu.be/EmnIdUvTRfk)/[OOP 개방폐쇄, 알파카](https://blog.itcode.dev/posts/2021/08/14/open-closed-principle)|개방폐쇄원칙은 Extension에 대해선 Open하고 Modification에 대해선 Closed해야 한다는 원칙이다. 객체의 확장에 제한이 없어야하고 따라서 확장으로 인한 객체 수정이 없어야 한다. 모듈화, 정보 은닉, 객체간 의존성 최소화 지향. 인터페이스 활용|
|-|ML Association Practice|개발: 데이터분석PY|[Association with Python, 2022 Ajou LN](https://github.com/ABizCho/py_machineLearning/blob/main/ML_PRAC/prac10_Association.py/ML10_0_Association-Python.ipynb)|pandas, seaborn, numpy, {mlxtend.preprocessing - TransactionEncoder,  mlxtend.frequent.frequent_patterns - apriori, association rules} 사용. 평가지표 : Support, Confidence, Lift|
|-|리액트 구글캘린더 클론코딩 REF|개발: PJ탐색|[구글 캘린더 리액트 클론코딩 REPO, 정미량](https://github.com/MiryangJung/google-calendar-weekly-clone)|뚜잇 프로젝트에 도움을 줄 수 있는 구글 캘린더 PJ 레포를 발견함 : 달력 위젯 등 구현방법 참고|
|-|=|=|[연관규칙분석 with Python, 꽁냥이 - Nice ref](https://zephyrus1111.tistory.com/119)/[장바구니 분석(apriori 알고리즘) 사용 및 해석, demonic](https://lemontia.tistory.com/903)|연관분석을 위한 Apriori의 방법과 원리 절차에 대해 더 자세히 알아보기 위한 참고자료들을 찾아보았다|
|22.05.16|Py Matplotlib 서브플롯 레이아웃|개발: 데이터분석PY|[서브플롯 간의 간격 조절, DataPlstachio](https://steadiness-193.tistory.com/174)|subplots_adjust, tight_layout(), constrained_layout 등의 메서드를 사용하여 레이아웃 조절 가능|
|-|Py matplotlib y축 뒤집은 차트|개발: 데이터분석PY|[Reverse Y-Axis in PyPlot](https://stackoverflow.com/questions/2051744/reverse-y-axis-in-pyplot)|가장 간단하게 ylim을 뒤집어 설정함으로써 해결 가능|
|-|Py jupyter노트북 nbextensions 기능 적용|개발: 데이터분석PY|[확장 기능! Nbextensions](https://bio-info.tistory.com/14)|nbextensions를 통해 코드폴딩, html&pdf 변환 등의 기능을 주피터에서 수행 가능|
|22.05.14|멀티스레드 환경의 OOP vs FP|개발: 프로그래밍 패러다임|[함수형 프로그래밍, 포프](https://youtu.be/XoH9jzblxKQ)|C 등의 OOP기반 플밍 시 멀티스레드 환경에선 레이스컨디션이 발생-이를 막기위해 락 or 아토믹 등을 사용하면 성능저하.But 이를 사용하지 않을 시 C가 훨씬 빠름. 함수형은 immutable한 특성으로 멀티스레드의 레이스컨디션 영향X, 그게 다임. 어제 엘리님영상에선 FP의 장점만을 봤는데 현실적인 면도 볼수 있었음|
|22.05.13|BST & AVL트리|개발: 자료구조|오늘자 DS 강의노트, [BST 코드, 참조](https://skeo131.tistory.com/163?category=420274), [BST 강의, 이재규](https://ddmix.blogspot.com/2015/01/cppalgo-15-binary-tree-search.html),|BST는 O(logn)의 효율적 탐색을 위한 이진트리 구조, AVL은 균형이진탐색 트리로 Balance Factor를 판별하여 균형 유지-> 탐색의 균일효율보장, but AVL은 생성 시 오버헤드|
|-|ML Association, Sequence Analysis 이론|머신러닝: 이론|2022 1st DA-ML, Ajou Univ.|연관분석은 비지도 학습의 대표적 방법. 과거 소비행동데이터로부터 패턴을 찾도록 도와줌. 장바구니 분석, sequence분석 으로도 불림. Apriori 연관규칙에 따라 각 항목의 조건부 발생 빈도로 지지도 계산하여 연관규칙 추출한다. 상업적으로 매우 유용한 분석법임|
|-|BST의 중복키 문제|개발: 자료구조|[BST 왜 중복노드 안되는걸까](https://muckycode.blogspot.com/2015/01/binary-search-treebst.html), [BST 중복키 해결법, Jake Lee](https://www.youtube.com/watch?v=obPNXABwwUA)|BST의 중복노드를 가정할 때, 1.중복 존재 가능성을 배제하여 탐색한다면 필요없는 노드를 가지는 것, 2. 중복노드를 존재를 인정한다면, 언제나 중복을 고려하여 불필요한 경우에도 최하위 리프노드까지의 탐색을 이어가야 함 /=> 두 경우 모두 비효율,but 그나마 이진트리+연결리스트 로 유사 해결법 존재|
|-|프라이빗 클라우드 VDI전환 케이스|개발: 기업사례|[SK C&C 프라이빗 클라우드 VDI 전환, IDG](https://acrobat.adobe.com/link/review?uri=urn:aaid:scds:US:3b14a39a-c24e-34e3-865f-a4d0b0f7379b)|HPE 그린레이크-심플리비티 솔루션을 활용한 기업의 VDI로의 성공적인 전환사례를 다룬 케이스스터디 보고서를 읽었다,클라우드에 대한 지식이 거의 전무하여 개념,용어를 찾아가며 읽어야 했지만 큰 규모의 서비스 전환은 어떤 방법으로 이뤄지는지 미약하게나마 엿볼 수 있었다.|
|-|함수형 프로그래밍 개념|개발: 프로그래밍 패러다임|[함수형 프로그래밍이 대세다?,드림코딩](https://youtu.be/4ezXhCuT2mw)|빅데이터 등 데이터처리 요구의 증가로, 병렬적 데이터 처리의 안정적,효율적 처리가 부각받기 시작 -> 함수형 프로그래밍 주목 / 특징으로는 1.순수함수, 2.비상태, 불변성 유지 3.if,for 등을 사용하지 않는 expression only 특징 4.First class함수: 함수를 변수로 사용하는 등, higher-order functions:함수를 인자로 전달,반환 /+(Monad, semigroup 등의 특징을 이해할 필요)|
|-|2022 AWS summit korea|개발: AWS 클라우드|[2022 AWS summit korea 기조연설,신한투자,당근마켓 케이스 등](https://summits-korea.virtual.awsevents.com/media/Day%201%20%EA%B8%B0%EC%A1%B0%EC%97%B0%EC%84%A4/1_14g8gbrb)|하교길에 AWS서밋에 등록했던 알림이 와서 봤다, 막연했던 클라우드의 개념을 기조연설과 다양한 최신 국내 파트너사의 현업 도입사례를 통해 얕게나마 구체화시킬 수 있었음, 특히 온프레미스와 클라우드의 장단점을 대조한 설명이 많았다. 기조연설에서 CEO는 머신러닝 등 자사의 Saas를 더욱 강조하는 듯 했는데, 오늘 ML강의의 타 조의 케이스스터디 발표가 네이버의 신세대 Aiaas 클로바를 주제로하였기에 더욱 인상적이었음. IT기업의 saas에 대한 요구와 이목이 집중되는걸 체감|
|22.05.12|파이어베이스 기초지식|개발: DB지식|[파이어베이스란 무엇인가? 1~3, 위시켓](https://blog.wishket.com/%ED%8C%8C%EC%9D%B4%EC%96%B4%EB%B2%A0%EC%9D%B4%EC%8A%A4firebase%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80-%ED%8C%8C%EC%9D%B4%EC%96%B4%EB%B2%A0%EC%9D%B4%EC%8A%A4-%EC%8B%AC%EC%B8%B5-%ED%83%90/)|포트폴리오 페이지에 사용할 기술 후보 탐색 중 가볍게 알아봄|
|-|VS코드 저장시 자동포맷 파일 지정|개발: 에디터|[Visual Studio code에서 저장시 자동 포맷](https://gyuha.tistory.com/500)|-|
|-|개발자 마인드셋|개발:마인드|[코딩실력보다 중요한 것](https://youtu.be/0uRj72i-7gg)|프로젝트로부터 배우는 것을 모래성처럼 사라지게 두지 말라, 가장 중요한 것은 성실|
|-|영국의 개발문화가 요구하는 전문가|개발: 자기개발|[백발의 개발자가 되기 위한 커리어 패스, 박경훈](https://zdnet.co.kr/view/?no=20141106211852)|영국의 개발업계는 개인의 생산성보다도 동료의 삽질을 사전에 막을 수 있는 능력을 더 높은 수준으로 평가한다. 순응하지 말고 발전하기 위해 끊임없이 노력하자.|
|-|Dreyfus Model in Dev|개발: 자기개발|[Management, Software Development / 글쓴이 josephjang](http://blog.lastmind.io/archives/593)|Dreyfus 모델에서 난 Novice에 해당하는 것 같다. 드라이퍼스 모델은 경험과 직관을 매우 중요한 요소로 여김, 모델 상 중상급 이상 수준은 20% 이하, 시간이 모든걸 해결하지 않는다는 사실 내포|
|22.05.11|A* vs JPS|개발: 알고리즘:길찾기|[[길찾기 알고리즘] A*냐 JPS냐 ... 그것이 문제로다!](https://www.youtube.com/watch?v=rfOgaPXCADQ)|전략게임에서의 길찾기는 JPS!, 현업에서의 고민과 해답을 찾아가는 접근 방법 또한 인상적으로 배움|
|-|허프만 코드(힙)|개발: 자료구조|[내 노트 : [DS] 허프만 코드 : 힙의 응용](https://velog.io/@he1256/%ED%97%88%ED%94%84%EB%A7%8C-%EC%BD%94%EB%93%9C-%ED%9E%99%EC%9D%98-%EC%9D%91%EC%9A%A9)|오늘의 자료구조 수업에선 허프만 코드 등을 배우고 이를 노트에 정리했다, 압축의 원리에 대해 배워서 내가 써왔던 ZIP툴은 어떤 알고리즘을 응용한 것인지 궁금했는데 서칭해보니 허프만 코드를 이용한다고|
|-|해시 테이블 개념복습|개발: 자료구조|[해쉬테이블에 대해 알아보고 구현하기](https://www.youtube.com/watch?v=Vi0hauJemxA)|자구 수업에서 배운 해시테이블을 복습하기 위해 하교길에 본 간단한 영상, 설명 정말 깔끔하심!|
|-|AR 디바이스 동향 및 생태계 예측|개발: XR트렌드|[내 노트 : Trend of AR Device and New Paradigm to be derived, May 2022](https://velog.io/@he1256/%EB%AF%B8%EC%99%84%EC%84%B1-AR-%EB%94%94%EB%B0%94%EC%9D%B4%EC%8A%A4-%EB%8F%99%ED%96%A5%EA%B3%BC-%ED%8C%8C%EC%83%9D%EB%90%A0-%EC%83%9D%ED%83%9C%EA%B3%84%EC%97%90-%EB%8C%80%ED%95%9C-%EC%8A%A4%ED%84%B0%EB%94%94-%EB%B0%8F-%EC%A0%9C%EC%95%88-Trend-of-AR-Device-and-New-Paradigm-to-be-derived-May-2022)|Apple의 AR Glasses 출시를 앞두고 미래의 생태계를 예측하여 대비하고 싶어서 보고서를 작성하기 시작했다.|
|-|=|=|[개화기에 들어선 XR 시장: 시장현황과 각 기업들의 전략](https://www.youtube.com/watch?v=6APbk7Kx84I&t=30s)|=|
|-|인상적인 퀄리티의 개발자란?|개발: 자기개발|[해외 CTO 가 말한 really impressed with the quality](https://thingsthis.tistory.com/123)|코드 퀄리티를 중요시 여기는 개발자가 되자, Competent 수준의 개발자를 어떻게든 찾아내고 그의 코드를 많이 참고하고 배워 내 것으로 소화할 것.|


